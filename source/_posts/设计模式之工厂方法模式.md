---
title: '设计模式之工厂方法模式'
date: 2020-11-09
tags:
- 工厂 设计模式 
categories:
- 设计模式
---

### 设计模式之工厂方法模式 

又称虚拟构造函数、Virtual Constructor、Factory Method

#### 一、定义

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

#### 二、方案

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

#### 三、适合应用场景

1. 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。
2. 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
3. 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

#### 四、实现方式

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。
5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。

#### 五、优缺点

-  你可以避免创建者和具体产品之间的紧密耦合。✔
-  *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。✔
-  *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。✔
- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。×

#### 六、代码实例

```c#
/// <summary>
/// 工厂方法模式 
/// </summary>
namespace DesignModel.FactoryMethod
{
    /// <summary>
    /// 创建者
    /// Creator类声明了要返回的工厂方法
    /// </summary>
    abstract class Creator
    {
        //Product类的对象。创建者的子类通常提供此方法的实现。
        public abstract IProduct FactoryMethod();
        public string SomeOperation()
        {
            var product = FactoryMethod();
            var str = "使用同一创建者代码执行" + product.Operation();
            return str;
        }
    }

    class CreatorA : Creator
    {
        public override IProduct FactoryMethod()
        {
            return new ProductA();
        }
    }

    class CreatorB : Creator
    {
        public override IProduct FactoryMethod()
        {
            return new ProductB();
        }
    }

    /// <summary>
    /// 产品接口
    /// </summary>
    public interface IProduct
    {
        string Operation();
    }

    /// <summary>
    /// 产品A实现的是 1+2
    /// </summary>
    class ProductA : IProduct
    {
        public string Operation()
        {
            return "产品A的操作是 1+2";
        }
    }

    /// <summary>
    /// 产品B实现的是 1*2
    /// </summary>
    class ProductB : IProduct
    {
        public string Operation()
        {
            return "产品B的操作 1*2";
        }
    }
}
```

 

```c#
    class Program
    {
        static void Main(string[] args)
        {
            CreatorA creatorA = new CreatorA();
            Console.WriteLine(creatorA.SomeOperation());

            CreatorB creatorB = new CreatorB();
            Console.WriteLine(creatorB.SomeOperation());

            Console.ReadLine();
        }
    }
```



[![B74WSU.png](https://s1.ax1x.com/2020/11/09/B74WSU.png)](https://imgchr.com/i/B74WSU)









