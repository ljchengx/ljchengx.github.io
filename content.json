{"meta":{"title":"Hexo","subtitle":"","description":"","author":"ljchengx","url":"http://www.ljchengx.cn","root":"/"},"pages":[{"title":"关于","date":"2020-01-16T09:05:58.000Z","updated":"2021-03-09T07:51:38.448Z","comments":false,"path":"about/index.html","permalink":"http://www.ljchengx.cn/about/index.html","excerpt":"","text":"Aboutljchengx人生若只如初见，何事秋风悲画扇NameljchengxEmail759990553@qq.comInterest代码开发，项目管理Skills HobbyGame,CarGitHubhttps://github.com/ljchengxWeChat"},{"title":"categories","date":"2020-01-17T01:03:10.000Z","updated":"2021-03-09T07:51:38.448Z","comments":false,"path":"categories/index.html","permalink":"http://www.ljchengx.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-17T01:03:46.000Z","updated":"2021-03-09T07:51:38.452Z","comments":false,"path":"tags/index.html","permalink":"http://www.ljchengx.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker系列之常用命令","slug":"Docker系列之常用命令","date":"2021-03-09T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/03/09/Docker系列之常用命令/","link":"","permalink":"http://www.ljchengx.cn/2021/03/09/Docker%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"帮助命令123docker version # 显示版本信息docker info # 系统信息docker 命令 --help #万能命令帮助文档地址：https://docs.docker.com/engine/reference镜像命令docker images 查看所有本地的主机上的镜像1234567891011121314[root@VM-0-11-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest d1165f221234 10 hours ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IdCREATED 镜像的创建时间SIZE 镜像的大小#可选项-a 全部镜像-q 只显示Iddocker search 搜索镜像12345678910[root@VM-0-11-centos ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10578 [OK] mariadb MariaDB Server is a high performing open sou… 3957 [OK] # 可选项 docker serach --help--filter=STARS=5000 # 结果是STARS大于5000[root@VM-0-11-centos ~]# docker search mysql --filter=STARS=5000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10578 [OK]docker pull 下载镜像1234567891011121314151617181920212223242526272829303132333435363738394041# 下载镜像 docker pull 镜像名称 可以指定Tag 版本号[root@VM-0-11-centos ~]# docker pull mysqlUsing default tag: latest # 如果不写tag 默认latestlatest: Pulling from library/mysqla076a628af6f: Pull complete # 分层下载 docker images核心 联合文件系统f6c208f3f991: Pull complete 88a9455a9165: Pull complete 406c9b8427c6: Pull complete 7c88599c0b25: Pull complete 25b5c6debdaf: Pull complete 43a5816f1617: Pull complete 1a8c919e89bf: Pull complete 9f3cf4bd1a07: Pull complete 80539cea118d: Pull complete 201b3cad54ce: Pull complete 944ba37e1c06: Pull complete Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c # 签名信息Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址 # 等价于它 docker pull mysql docker pull docker.io/library/mysql:latest# 指定版本[root@VM-0-11-centos ~]# docker pull mysql:5.75.7: Pulling from library/mysqla076a628af6f: Already exists f6c208f3f991: Already exists 88a9455a9165: Already exists 406c9b8427c6: Already exists 7c88599c0b25: Already exists 25b5c6debdaf: Already exists 43a5816f1617: Already exists 1831ac1245f4: Pull complete 37677b8c1f79: Pull complete 27e4ac3b0f6e: Pull complete 7227baa8c445: Pull complete Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7docker rmi 删除命令12docker rmi -f 镜像Id # 删除指定的镜像 docker rmi -f $(docker images -aq) # 删除全部镜像容器命令说明：我们有了镜像才可以创建容器，linux 下载一个 centos镜像来测试学习1docker pull centos新建容器并启动123456789101112131415161718192021docker run [可选参数] image # 参数说明--name=\"Name\" 容器名字 tomcat01 tomcat02-d 后台方式运行-it 使用交互方式运行 进入容器查看内容-P 指定容器的端口 -p 8080:8080 -p 主机端口:容器端口 （常用） -p 容器端口-p 随机指定端口 # 测试 启动并进入容器[root@VM-0-11-centos ~]# docker run -it centos /bin/bash[root@17ad4c340398 /]# ls 查看容器内的centos 基础版本 很多命令不完善 bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 从容器中退回主机[root@17ad4c340398 /]# exit exit[root@VM-0-11-centos /]# lsbin boot data dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var列出所有运行的容器123456789# docker ps-a # 列出当前正在运行的容器 +带出历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号[root@VM-0-11-centos /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-11-centos /]# docker ps -a17ad4c340398 centos \"/bin/bash\" 4 minutes ago Exited (0) 2 minutes ago e684eccc0807 d1165f221234 \"/hello\" 2 days ago Exited (0) 2 days ago退出容器12exit # 退出容器Ctrl + P + Q # 退出不停止删除容器123docker rm 容器id # 删除指定容器 不能删除正在运行的容器 docker rm -f $(docker ps -aq) # 删除所有的容器 docker ps -a -q|xargs docker rm # 删除所有的容器启动和停止容器的操作1234docker start 容器id # 启动docker restart 容器id # 重启docker stop 容器id # 停止 docker kill 容器id # 杀进程常用其他命令后台启动容器12345678# 通过 docker run -d 镜像名 后台启动[root@VM-0-11-centos ~]# docker run -d centosd269c3553f1b40ff62ea5a23635ff330cb28f857c2d8c10073c95545b56dffcc# 通过docker ps 发现停止了# 常见坑 容器使用后台运行 就必须要有一个前台进程 docker发现没有应用 就会自动停止# nginx 容器启动后 发现自己没有服务 就会立即停止 就是没有程序了常看日志命令123456789101112131415161718# docker logs 日志命令 docker logs -tf --tail 10 容器 没有日志# 编写脚本 [root@VM-0-11-centos ~]# docker run -d centos /bin/sh -c \"while true;do echo ljchengx;sleep 2;done\"# 查看[root@VM-0-11-centos ~]# docker psCONTAINER ID IMAGE c6d3be37906b centos # 查看日志 指定行数-tf -- tail count 显示的行数[root@VM-0-11-centos ~]# docker logs -tf --tail 10 c6d3be37906b # 显示全部[root@VM-0-11-centos ~]# docker logs -tf c6d3be37906b查看进程信息12345# top 命令[root@VM-0-11-centos ~]# docker top c6d3be37906bUID PID PPID C STIME root 17058 17035 0 10:07 root 31240 17058 0 10:17**查看元数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211# docker inspect 容器Id# 测试[root@VM-0-11-centos ~]# docker inspect c6d3be37906b[ &#123; \"Id\": \"c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe\", \"Created\": \"2021-03-09T02:07:54.08862076Z\", \"Path\": \"/bin/sh\", \"Args\": [ \"-c\", \"while true;do echo ljchengx;sleep 2;done\" ], \"State\": &#123; \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 17058, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-09T02:07:54.429353159Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" &#125;, \"Image\": \"sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55\", \"ResolvConfPath\": \"/var/lib/docker/containers/c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe/hostname\", \"HostsPath\": \"/var/lib/docker/containers/c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe/hosts\", \"LogPath\": \"/var/lib/docker/containers/c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe/c6d3be37906be8467a4cbb8f4d25f48176b406f9e9161ab85a738e3e9a7674fe-json.log\", \"Name\": \"/gallant_jemison\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": null, \"HostConfig\": &#123; \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": &#123; \"Type\": \"json-file\", \"Config\": &#123;&#125; &#125;, \"NetworkMode\": \"default\", \"PortBindings\": &#123;&#125;, \"RestartPolicy\": &#123; \"Name\": \"no\", \"MaximumRetryCount\": 0 &#125;, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 0, 0 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] &#125;, \"GraphDriver\": &#123; \"Data\": &#123; \"LowerDir\": \"/var/lib/docker/overlay2/d5315d260b6f52455014e1a6bc5275a9f81ca40586b33bdf30bb25f6a38835aa-init/diff:/var/lib/docker/overlay2/93fbbcebc66cf30fe7524759b101b0ec71ee5de3c3e12c884988e10ea8b94a0a/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/d5315d260b6f52455014e1a6bc5275a9f81ca40586b33bdf30bb25f6a38835aa/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/d5315d260b6f52455014e1a6bc5275a9f81ca40586b33bdf30bb25f6a38835aa/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/d5315d260b6f52455014e1a6bc5275a9f81ca40586b33bdf30bb25f6a38835aa/work\" &#125;, \"Name\": \"overlay2\" &#125;, \"Mounts\": [], \"Config\": &#123; \"Hostname\": \"c6d3be37906b\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\": [ \"/bin/sh\", \"-c\", \"while true;do echo ljchengx;sleep 2;done\" ], \"Image\": \"centos\", \"Volumes\": null, \"WorkingDir\": \"\", \"Entrypoint\": null, \"OnBuild\": null, \"Labels\": &#123; \"org.label-schema.build-date\": \"20201204\", \"org.label-schema.license\": \"GPLv2\", \"org.label-schema.name\": \"CentOS Base Image\", \"org.label-schema.schema-version\": \"1.0\", \"org.label-schema.vendor\": \"CentOS\" &#125; &#125;, \"NetworkSettings\": &#123; \"Bridge\": \"\", \"SandboxID\": \"79bdc9c626a1158ae89f85850a2e1f1388c9263d3a1da8567d04e470dce27a9f\", \"HairpinMode\": false, \"LinkLocalIPv6Address\": \"\", \"LinkLocalIPv6PrefixLen\": 0, \"Ports\": &#123;&#125;, \"SandboxKey\": \"/var/run/docker/netns/79bdc9c626a1\", \"SecondaryIPAddresses\": null, \"SecondaryIPv6Addresses\": null, \"EndpointID\": \"13c3c223789749fc5b64c10fc35992d1e0df64dfa9cb73691eea8f6d51317522\", \"Gateway\": \"172.17.0.1\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"IPAddress\": \"172.17.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"MacAddress\": \"02:42:ac:11:00:02\", \"Networks\": &#123; \"bridge\": &#123; \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"9a1d22b0ff0846b37b84fd7179511a6a6065f1c6becd2833f9a21b74f28d6bf2\", \"EndpointID\": \"13c3c223789749fc5b64c10fc35992d1e0df64dfa9cb73691eea8f6d51317522\", \"Gateway\": \"172.17.0.1\", \"IPAddress\": \"172.17.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:11:00:02\", \"DriverOpts\": null &#125; &#125; &#125; &#125;]进入当前容器的命令1234567891011121314151617181920212223242526# 命令 进入docker exec -it 容器Id baseshell# 测试[root@VM-0-11-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc6d3be37906b centos \"/bin/sh -c 'while t…\" 4 hours ago Up 4 hours gallant_jemison[root@VM-0-11-centos ~]# docker exec -it c6d3be37906b /bin/bash[root@c6d3be37906b /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@c6d3be37906b /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 02:07 ? 00:00:01 /bin/sh -c while true;do echo ljchengx;sleep 2;doneroot 6656 0 0 05:49 pts/0 00:00:00 /bin/bashroot 6682 1 0 05:50 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2root 6683 6656 0 05:50 pts/0 00:00:00 ps -ef# 方式二docker attach 容器Id# 进入正在执行的[root@VM-0-11-centos ~]# docker attach c6d3be37906b# 区别exec 新终端attach 打开正在运行的终端容器内拷贝文件到主机123456789101112131415161718192021# docker cp 容器Id:路径/文件名 /主机路径[root@VM-0-11-centos home]# docker attach ecf8bbccec70[root@ecf8bbccec70 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@ecf8bbccec70 /]# cd /home[root@ecf8bbccec70 home]# touch test.java [root@ecf8bbccec70 home]# lstest.java[root@ecf8bbccec70 home]# exitexit[root@VM-0-11-centos home]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESecf8bbccec70 centos \"/bin/bash\" 7 minutes ago Exited (0) 30 seconds ago practical_panini[root@VM-0-11-centos home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-11-centos home]# docker cp ecf8bbccec70:/home/test.java /home[root@VM-0-11-centos home]# lsljchengx.java test.java# 拷贝属于手动过程总结12345678910111213141516171819202122232425262728docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等docker info 查看系统(docker)层面信息，包括管理的images, containers数等docker search &lt;image&gt; 在docker index中搜索imagedocker pull &lt;image&gt; 从docker registry server 中下拉imagedocker push &lt;image|repository&gt; 推送一个image或repository到registrydocker push &lt;image|repository&gt;:TAG 同上，指定tagdocker inspect &lt;image|container&gt; 查看image或container的底层信息docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)docker images -a 列出所有的imagesdocker ps 默认显示正在运行中的containerdocker ps -l 显示最后一次创建的container，包括未运行的docker ps -a 显示所有的container，包括未运行的docker logs &lt;container&gt; 查看container的日志，也就是执行命令的一些输出docker rm &lt;container...&gt; 删除一个或多个containerdocker rm `docker ps -a -q` 删除所有的containerdocker ps -a -q | xargs docker rm 同上, 删除所有的containerdocker rmi &lt;image...&gt; 删除一个或多个imagedocker start/stop/restart &lt;container&gt; 开启/停止/重启containerdocker start -i &lt;container&gt; 启动一个container并进入交互模式docker attach &lt;container&gt; attach一个运行中的containerdocker run &lt;image&gt; &lt;command&gt; 使用image创建container并执行相应命令，然后停止docker run -i -t &lt;image&gt; /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bashdocker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口docker commit &lt;container&gt; [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选docker build &lt;path&gt; 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的imagedocker build -t repo[:tag] 同上，可以指定repo和可选的tagdocker build - &lt; &lt;dockerfile&gt; 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的imagedocker port &lt;container&gt; &lt;container port&gt; 查看本地哪个端口映射到container的指定端口，或者用docker ps 也可以看到。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"Docker","slug":"JAVA/Docker","permalink":"http://www.ljchengx.cn/categories/JAVA/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.ljchengx.cn/tags/Docker/"}]},{"title":"Docker系列之练习","slug":"Docker系列之练习","date":"2021-03-09T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/03/09/Docker系列之练习/","link":"","permalink":"http://www.ljchengx.cn/2021/03/09/Docker%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BB%83%E4%B9%A0/","excerpt":"","text":"一、使用Docker部署Nginx开始12345678910111213141516171819202122232425262728293031323334353637383940414243# 第一步 建议去docker hub搜索[root@VM-0-11-centos /]# docker search nginx# 第二步 下载[root@VM-0-11-centos /]# docker pull nginx# 启动 # 这里使用容器的80对应给主机的3344端口 重命名为nginx01# --name 重命名# -p 宿主机端口 [root@VM-0-11-centos /]# docker run -d --name nginx01 -p 3344:80 nginx # 查看# 通过curl 来验证访问主机的3344端口 这里直接返回了nginx默认页面[root@VM-0-11-centos /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES933ee17088da nginx \"/docker-entrypoint.…\" 55 seconds ago Up 54 seconds 0.0.0.0:3344-&gt;80/tcp nginx01[root@VM-0-11-centos /]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;1234# 进入容器[root@VM-0-11-centos /]# docker exec -it nginx01 /bin/bashroot@933ee17088da:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx思考：每次修改配置文件 需要进入容器达到容器外部修改文件 内部完成修改-v 数据卷技术二、使用Docker安装Tomcat1234567891011121314151617# 官方的使用$ docker run -it --rm tomcat:9.0# 之前的启动属于后台 停止后 容器还能查到 使用官方命令是用完即删# 自己使用 先下载 后启动[root@VM-0-11-centos /]# docker pull tomcat# 启动[root@VM-0-11-centos /]# docker run -d -p 3355:8080 --name tomcat01 tomcat# 测试访问没有问题# 进入容器[root@VM-0-11-centos /]# docker exec -it tomcat01 /bin/bash# 发现问题 linux命令少了 webapps下没有文件 默认最小镜像 所有不必要的文件去除 保证最小可运行的环境三、使用Docker部署elasticsearch12345678910111213# es 暴露的端口很多# es 十分耗内存 数据需要挂载# --net somenetwork 网络# 启动$ docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.10.1# 启动直接卡死 # 查看 docker stats # -e 环境配置修改docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-xms64m -xmx512m\" elasticsearch:7.10.1","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"Docker","slug":"JAVA/Docker","permalink":"http://www.ljchengx.cn/categories/JAVA/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.ljchengx.cn/tags/Docker/"}]},{"title":"Docker系列之安装","slug":"Docker系列之安装","date":"2021-03-08T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/03/08/Docker系列之安装/","link":"","permalink":"http://www.ljchengx.cn/2021/03/08/Docker%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%89%E8%A3%85/","excerpt":"","text":"Docker之安装安装环境准备1.Linux服务器 Centos72.远程连接环境查看123#系统内核是3.10以上[root@VM-0-11-centos ~]# uname -r3.10.0-1127.19.1.el7.x86_6412345678910111213141516#系统详细情况NAME=\"CentOS Linux\"VERSION=\"7 (Core)\"ID=\"centos\"ID_LIKE=\"rhel fedora\"VERSION_ID=\"7\"PRETTY_NAME=\"CentOS Linux 7 (Core)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:centos:centos:7\"HOME_URL=\"https://www.centos.org/\"BUG_REPORT_URL=\"https://bugs.centos.org/\"CENTOS_MANTISBT_PROJECT=\"CentOS-7\"CENTOS_MANTISBT_PROJECT_VERSION=\"7\"REDHAT_SUPPORT_PRODUCT=\"centos\"REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"安装帮助文档：123456789101112131415161718192021222324252627282930# 1、卸载旧文件yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、需要的安装包yum install -y yum-utils# 3、设置镜像的仓库yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认国外 yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云# 更新yum 索引yum makecache fast# 4、安装docker docker-ce 社区版yum install docker-ce docker-ce-cli containerd.io# 5、启动dockersystemctl start docker# 6、使用docker version 查看是否安装成功12# 7、rundocker run hello-world12# 8、查看下载的hello-word 镜像docker images1234567# 9、卸载# 卸载依赖yum remove docker-ce docker-ce-cli containerd.io# 删除资源rm -rf /var/lib/dockerrm -rf /var/lib/containerd阿里云镜像加速1、登录阿里云 容器镜像服务2、找到镜像服务加速地址 左下角位置 找到对应系统3、配置1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://ki5mdt9h.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker回顾流程1.开始2.Docker会在本机寻找镜像3.判断本机是否有镜像4.有镜像就运行 没有就去仓库下载5.找到了下载并运行底层原理docker是如何工作的？Docker是-个Client Server结构的系统, Docker的守护进程运行在主机上。通过Socket从客户端访问 !Docker Server接收到Docker-Client的指令,就会执行这个命令!docker为什么比Vm快？1、docker比虚拟机有着更少的抽象层2、docker利用的是宿主机的内核所以说,新建一个容器的时候 , docker不需要想虚拟机一样重新加载一个操作系统内核 ,避免引导。虚拟机是加载GuestOS ,分钟级别的,而docker是利用宿主机的操作系统吗,省略了这个复杂的过程,秒级!","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"Docker","slug":"JAVA/Docker","permalink":"http://www.ljchengx.cn/categories/JAVA/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.ljchengx.cn/tags/Docker/"}]},{"title":"SpringCloud系列之Eureka(四)","slug":"SpringCloud系列之Eureka(四)","date":"2021-02-24T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/02/24/SpringCloud系列之Eureka(四)/","link":"","permalink":"http://www.ljchengx.cn/2021/02/24/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka(%E5%9B%9B)/","excerpt":"","text":"Hystrix熔断器：优点：1.快速失效 不用等业务超时时间 返回默认值2.服务正常，自动连接到业务三种状态：关闭 打开 半开1.不是调用失败立即打开2.调用次数达到阀值 服务出异常 打开断路器3.过一个时间窗口 重新调用如果服务调用失败 就是调用FallBack1.服务提供者这里使用的还是之前的提供者模块spring-cloud-eureka-client1.pom.xml12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml配置文件1234567891011server: port: 9992spring: application: name: spring-cloud-order-service-providereureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.controller逻辑代码1234567891011@RestController@RequestMapping(\"/order\")public class OrderStatisticServiceController &#123; @Value(\"$&#123;server.port&#125;\") private Integer port; @GetMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return \"getResult = \" + port + \"--\" + +id; &#125;&#125;4.启动Eureka服务，启动服务提供者2.服务调用者这里服务调用者我们使用Feign的方式来处理 项目参考Feign的配置我们新建一个子module命名为spring-cloud-user-hystrix-consumer1.pom.xml这里注意一下 我们在Feign的基础上需要添加Hystrix的依赖123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml配置文件换个名称和端口即可1234567891011server: port: 9997spring: application: name: spring-cloud-user-hystrix-consumer # 应用名称，应用名称会在Eureka中作为服务名称eureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.Feign的接口使用Feign来完成服务调用12345@FeignClient(name = \"spring-cloud-order-service-provider\")public interface IResultInterface &#123; @RequestMapping(value = \"/order/getResult/&#123;id&#125;\") String getResult(@PathVariable(\"id\") Integer id);&#125;4.Controller这里需要注意 我们在写自己调用方法的同时，就需要引入熔断器的fallback，当我们的服务提供者无法访问的时候，触发熔断器则进入自定义写的类似回调方法123456789101112131415161718@RestController@RequestMapping(\"/order\")public class ResultController &#123; @Autowired IResultInterface iResultInterface; @RequestMapping(\"/getResult/&#123;id&#125;\") @HystrixCommand(fallbackMethod = \"fallbackGetResult\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return iResultInterface.getResult(id); &#125; //触发熔断器的返回值 public String fallbackGetResult(Integer id)&#123; return \"这里进入熔断器的默认值\"; &#125;&#125;5.启动项目启动完成，我们来验证一下；浏览器地址输入：http://localhost:9997/order/getResult/1234567这个时候返回的结果是：说明当前通过Feign来调用9992端口的服务提供者方法成功然后我们把服务提供者的端口停掉，刷新请求看看效果这里发现进入我们的fallback的自定义方法里了，说明熔断器触发成功。代码已上传至Github","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"SpringCloud","slug":"JAVA/SpringCloud","permalink":"http://www.ljchengx.cn/categories/JAVA/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.ljchengx.cn/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"http://www.ljchengx.cn/tags/Hystrix/"}]},{"title":"SpringCloud系列之Eureka(三)","slug":"SpringCloud系列之Eureka(三)","date":"2021-02-23T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/02/23/SpringCloud系列之Eureka(三)/","link":"","permalink":"http://www.ljchengx.cn/2021/02/23/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka(%E4%B8%89)/","excerpt":"","text":"Feign我们在进行微服务项目的开发的时候，经常会遇到一个问题，比如A服务是一个针对用户的服务，里面有用户的增删改查的接口和方法，而现在我有一个针对产品的服务B服务中有一个查找用户的需求，这个时候我们可以在B服务里再写一个查找用户的接口，可是就为了一个接口就得从控制层到持久层都写一遍怎么看都不值当，最关键的是这个接口在别的服务里面还有，这就更不应该做了，所以springCloud提供了服务调用的方法——feign。一、Feign1.Eureka注册中心注册中心较为简单，这里就不多赘述，不清楚的可以参考系列第一篇。2.服务提供者pom.xml文件如下：12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml文件需要修改配置1234567891011server: port: 9992spring: application: name: spring-cloud-order-service-providereureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka //这里是server工程地址 register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项需要添加的注解和server不一样，使用@EnableDiscoveryClient1234567@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125;4.我们这边写一个方法，等下使用，新建一个controller文件夹，创建一个controller.1234567891011@RestController@RequestMapping(\"/order/data\")public class OrderStatisticServiceController &#123; @Value(\"$&#123;server.port&#125;\") private Integer port; @GetMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return \"getResult = \" + id; &#125;&#125;5.启动当前服务提供者这里在server页面就可以看到已经注册成功。3.服务调用者Feign依赖于Eureka环境，所以我们在上面的基础上新增一个子module即可1.pom.xml文件如下,相比上面简单调用的第四步多一个关于Feign的依赖1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml配置文件1234567891011server: port: 9994spring: application: name: spring-cloud-user-feign-consumer # 应用名称，应用名称会在Eureka中作为服务名称eureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项相比上面的调用者多个@EnableFeignClients注解12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125;4.我们使用Feign需要创建一个接口 这里举个简单的例子12345@FeignClient(name = \"spring-cloud-order-service-provider\") //这里是服务提供者在Eureka中的名称public interface IResultInterface &#123; @RequestMapping(value = \"/order/getResult/&#123;id&#125;\") //服务提供者的接口路由 String getResult(@PathVariable(\"id\") Integer id);&#125;5.我们创建当前module的Controller调用的接口123456789101112@RestController@RequestMapping(\"/order\")public class ResultController &#123; @Autowired IResultInterface iResultInterface; //这里使用接口来完成方法的请求 @RequestMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return iResultInterface.getResult(id); &#125;&#125;6.启动并访问看看效果这里看到我们请求的是9994的新的服务调用者工程 但是返回值的服务提供者的结果，说明这里Feign使用成功。代码已上传至Github","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"SpringCloud","slug":"JAVA/SpringCloud","permalink":"http://www.ljchengx.cn/categories/JAVA/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.ljchengx.cn/tags/SpringCloud/"},{"name":"Feign","slug":"Feign","permalink":"http://www.ljchengx.cn/tags/Feign/"}]},{"title":"SpringCloud系列之Eureka(二)","slug":"SpringCloud系列之Eureka(二)","date":"2021-02-23T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/02/23/SpringCloud系列之Eureka(二)/","link":"","permalink":"http://www.ljchengx.cn/2021/02/23/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka(%E4%BA%8C)/","excerpt":"","text":"Ribbon一、服务提供者1.Eureka注册中心注册中心较为简单，这里就不多赘述，不清楚的可以参考上一篇。2.创建服务提供者这里我们先创建一个spring-cloud-eureka-client子module1.pom.xml文件为：12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml配置文件1234567891011server: port: 9992spring: application: name: spring-cloud-order-service-providereureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项添加注解@EnableDiscoveryClient1234567@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125;4.添加controller 这里根据自己需要写方法1234567891011@RestController@RequestMapping(\"/order\")public class OrderStatisticServiceController &#123; @Value(\"$&#123;server.port&#125;\") private Integer port; @GetMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return \"getResult = \" + port + \"--\" + +id; &#125;&#125;5.同理创建第二个服务提供者spring-cloud-eureka-client2pom.xml12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;yml 端口改变，名称不变1234567891011server: port: 9995spring: application: name: spring-cloud-order-service-providereureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true启动器和controller基本一致123456789101112131415161718@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClient2Application &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClient2Application.class, args); &#125;&#125;@RestController@RequestMapping(\"/order\")public class OrderStatisticServiceController &#123; @Value(\"$&#123;server.port&#125;\") private Integer port; @GetMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; return \"getResult = \" + port + \"--\" + +id; &#125;&#125;6.启动两个服务提供者我们在注册中心看看效果这里两个不同端口的同一个服务的提供者完成。二、服务调用者上面我们创建了服务提供者，现在我们来创建服务调用者创建一个子module命名为spring-cloud-eureka-ribbon 因为eureka依赖本身已经带有ribbon，我们在使用中不需要额外引入。1.pom.xml12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml文件1234567891011server: port: 9996spring: application: name: spring-cloud-user-ribbon-consumer # 应用名称，应用名称会在Eureka中作为服务名称eureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项1234567@SpringBootApplication@EnableDiscoveryClientpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125;4.配置项由于我们使用的是RestTemplate来完成请求添加RestTemplateConfiguration，这里需要添加注解@LoadBalanced 使用轮询来请求12345678@Configurationpublic class RestTemplateConfiguration &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125;然后来处理我们的controller1234567891011121314@RestController@RequestMapping(\"/ribbon\")public class RibbonController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/getResult/&#123;id&#125;\") public String getResult(@PathVariable(\"id\") Integer id) &#123; String url = \"http://\" + \"spring-cloud-order-service-provider\" + \"/order/getResult/\" + id; return restTemplate.getForObject(url, String.class); &#125;&#125;这里url就是我们服务提供者的名称来组成的。5.启动并请求浏览器http://localhost:9996/ribbon/getResult/123456刷新几次可以看看结果：这里分别出现了两个不同的结果，变化的就是服务提供者的端口，可以说明我们的ribbon使用成功。代码已上传至Github","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"SpringCloud","slug":"JAVA/SpringCloud","permalink":"http://www.ljchengx.cn/categories/JAVA/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.ljchengx.cn/tags/SpringCloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"http://www.ljchengx.cn/tags/Ribbon/"}]},{"title":"SpringCloud系列之Eureka","slug":"SpringCloud系列之Eureka","date":"2021-02-23T11:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2021/02/23/SpringCloud系列之Eureka/","link":"","permalink":"http://www.ljchengx.cn/2021/02/23/SpringCloud%E7%B3%BB%E5%88%97%E4%B9%8BEureka/","excerpt":"","text":"一、注册中心1.简单调用1.Parent项目主要父级依赖文件详细pom文件为：123456789101112131415161718192021&lt;properties&gt; &lt;spring.cloud-version&gt;Hoxton.SR8&lt;/spring.cloud-version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud-version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;2.Eureka Server工程注册中心提供者1.创建一个子module在父级项目下 pom文件需要添加netflix-eureka-server123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.配置文件yml如下：123456789101112131415161718#eureka server服务端口server: port: 9991spring: application: name: spring-cloud-eureka-server # 应用名称，应用名称会在Eureka中作为服务名称 # eureka 客户端配置（和Server交互），Eureka Server 其实也是一个Clienteureka: instance: hostname: localhost # 当前eureka实例的主机名 client: service-url: # 配置客户端所交互的Eureka Server的地址（Eureka Server集群中每一个Server其实相对于其它Server来说都是Client） # 集群模式下，defaultZone应该指向其它Eureka Server，如果有更多其它Server实例，逗号拼接即可 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ register-with-eureka: false # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: false # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项需要添加注解@EnableEurekaServer：1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class,args); &#125;&#125;4.启动效果如下：这里注册服务完成，下面开始处理服务提供者。3.服务提供者服务提供者1.和server工程一样创建一个子module，不过需要添加的依赖不一样pom.xml文件如下：12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml文件需要修改配置1234567891011server: port: 9992spring: application: name: spring-cloud-order-service-providereureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka //这里是server工程地址 register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项需要添加的注解和server不一样，使用@EnableDiscoveryClient1234567@SpringBootApplication@EnableDiscoveryClientpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125;4.我们这边写一个方法，等下使用，新建一个controller文件夹，创建一个controller.123456789101112131415@RestController@RequestMapping(\"/order/data\")public class OrderStatisticServiceController &#123; @Value(\"$&#123;server.port&#125;\") private Integer port; /** * 根据用户id获取今日完单数 * @param id 用户ID * @return 完单数 */ @GetMapping(\"/getTodayFinishOrderNum/&#123;id&#125;\") public Integer getTodayFinishOrderNum(@PathVariable(\"id\") Integer id)&#123; return port; &#125;&#125;5.启动当前服务提供者这里在server页面就可以看到已经注册成功。4.服务调用者调用者整体配置内容和提供者相同，我们按照第三步来修改一下1.先创建一个子mudole pom.xml一样12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;2.yml修改下名称和端口号1234567891011server: port: 9993spring: application: name: spring-cloud-user-service-consumer # 应用名称，应用名称会在Eureka中作为服务名称eureka: client: service-url: defaultZone: http://127.0.0.1:9991/eureka register-with-eureka: true # ⾃⼰就是服务不需要注册⾃⼰ 集群模式下可以改成true fetch-registry: true # ⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，集群模式下可以改成true3.启动项也是新增@EnableDiscoveryClient 注解1234567@SpringBootApplication@EnableDiscoveryClientpublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125;4.这里我们也写一个controller ，在写controller之前写一个RestTemplate1234567@Configurationpublic class RestTemplateConfiguration &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125;5.然后我们写一个controller 这里通过服务提供者的名称 来调用第三步的方法123456789101112131415161718192021222324252627@RestController@RequestMapping(\"/user/data\")public class UserCenterController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @GetMapping(\"/getTodayStatistic/&#123;id&#125;\") public Integer getTodayStatistic(@PathVariable(\"id\") Integer id)&#123; // 使用discoveryClient 类能够与eureka server 交互， getInstances 获取注册到eureka server // 的\"spring-cloud-order-service-provider\" 实例列表 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"spring-cloud-order-service-provider\"); // 获取第一个服务信息 ServiceInstance instanceInfo = instances.get(0); //获取ip String ip = instanceInfo.getHost(); //获取port int port = instanceInfo.getPort(); String url =\"http://\"+ip+\":\"+port+\"/order/data/getTodayFinishOrderNum/\"+id; return restTemplate.getForObject(url, Integer.class); &#125;&#125;6.启动看看这里就出现了两个 我们来试试服务调用者我们在浏览器页面输入服务调用者的方法http://localhost:9993/user/data/getTodayStatistic/1001这里时候返回的是服务提供者的端口，验证通过，实际上最终方法调用的是9992端口的服务提供者的方法。以上一个Eureka简单调用方式流程完成。代码已上传至Github","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"SpringCloud","slug":"JAVA/SpringCloud","permalink":"http://www.ljchengx.cn/categories/JAVA/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.ljchengx.cn/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"http://www.ljchengx.cn/tags/Eureka/"}]},{"title":"设计模式之抽象工厂模式","slug":"设计模式之抽象工厂模式","date":"2020-11-09T16:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/11/10/设计模式之抽象工厂模式/","link":"","permalink":"http://www.ljchengx.cn/2020/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、定义抽象工厂是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。二、方案抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 椅子接口； 所有风格的咖啡桌都实现 咖啡桌接口， 以此类推。客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。三、适合应用场景如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。四、实现方式以不同的产品类型与产品变体为维度绘制矩阵。为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。为每种产品变体实现一个具体工厂类。在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。五、优缺点你可以确保同一工厂生成的产品相互匹配。✔你可以避免客户端和具体产品代码的耦合。✔单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。✔开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。✔由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。×六、代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace DesignModel.FactoryMethod&#123; /// &lt;summary&gt; /// 抽象工厂接口声明一组方法，这些方法返回不同的抽象产品。这些产品被称为一个系列 /// 与高层次的主题或概念相关的。一个家庭的产品是他们通常能够相互合作 /// 一个系列的产品可以有几个变体，但其中一个变体的产品不兼容用别人的产品 /// &lt;/summary&gt; public interface IAbstractFactory &#123; IAbstractProductA CreateProductA(); IAbstractProductB CreateProductB(); &#125; class ConcreteFactory1 : IAbstractFactory &#123; public IAbstractProductA CreateProductA() &#123; return new ConcreteProductA1(); &#125; public IAbstractProductB CreateProductB() &#123; return new ConcreteProductB1(); &#125; &#125; class ConcreteFactory2 : IAbstractFactory &#123; public IAbstractProductA CreateProductA() &#123; return new ConcreteProductA2(); &#125; public IAbstractProductB CreateProductB() &#123; return new ConcreteProductB2(); &#125; &#125; /// &lt;summary&gt; /// 产品系列中的每个不同产品都应该有一个基本接口。 /// 产品的所有变体都必须实现此接口。 /// &lt;/summary&gt; public interface IAbstractProductA &#123; string UsefulFunctionA(); &#125; class ConcreteProductA1 : IAbstractProductA &#123; public string UsefulFunctionA() &#123; return \"产品A1的结果\"; &#125; &#125; class ConcreteProductA2 : IAbstractProductA &#123; public string UsefulFunctionA() &#123; return \"产品A2的结果\"; &#125; &#125; public interface IAbstractProductB &#123; /// &lt;summary&gt; /// 产品B做自己的事情 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; string UsefulFunctionB(); /// &lt;summary&gt; /// 但它也可以与产品合作。 /// 抽象工厂确保它生产的所有产品都是有价值的 /// 相同的变体，因此，兼容。 /// &lt;/summary&gt; /// &lt;param name=\"collaborator\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; string AnotherUsefulFunctionB(IAbstractProductA collaborator); &#125; class ConcreteProductB1 : IAbstractProductB &#123; public string AnotherUsefulFunctionB(IAbstractProductA collaborator) &#123; var result = collaborator.UsefulFunctionA(); return $\"这是B1与&#123;result&#125;合作\"; &#125; public string UsefulFunctionB() &#123; return \"产品B1的结果\"; &#125; &#125; class ConcreteProductB2 : IAbstractProductB &#123; public string AnotherUsefulFunctionB(IAbstractProductA collaborator) &#123; var result = collaborator.UsefulFunctionA(); return $\"这是B2与&#123;result&#125;合作\"; &#125; public string UsefulFunctionB() &#123; return \"产品B2的结果\"; &#125; &#125;&#125;12345678910111213141516171819202122232425262728namespace DesignModel&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"用第一种工厂类型测试相同的客户端代码\"); ClientMethod(new ConcreteFactory1()); Console.WriteLine(); Console.WriteLine(\"用第二种工厂类型测试相同的客户端代码\"); ClientMethod(new ConcreteFactory2()); Console.ReadLine(); &#125; public static void ClientMethod(IAbstractFactory factory) &#123; var productA = factory.CreateProductA(); var productB = factory.CreateProductB(); Console.WriteLine(productB.UsefulFunctionB()); Console.WriteLine(productB.AnotherUsefulFunctionB(productA)); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ljchengx.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"工厂","slug":"工厂","permalink":"http://www.ljchengx.cn/tags/%E5%B7%A5%E5%8E%82/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.ljchengx.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"抽象","slug":"抽象","permalink":"http://www.ljchengx.cn/tags/%E6%8A%BD%E8%B1%A1/"}]},{"title":"设计模式之工厂方法模式","slug":"设计模式之工厂方法模式","date":"2020-11-08T16:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/11/09/设计模式之工厂方法模式/","link":"","permalink":"http://www.ljchengx.cn/2020/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"又称虚拟构造函数、Virtual Constructor、Factory Method一、定义工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。二、方案工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用 new运算符）。 不用担心， 对象仍将通过 new运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。三、适合应用场景当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。四、实现方式让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。五、优缺点你可以避免创建者和具体产品之间的紧密耦合。✔单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。✔开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。✔应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。×六、代码实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt;/// 工厂方法模式 /// &lt;/summary&gt;namespace DesignModel.FactoryMethod&#123; /// &lt;summary&gt; /// 创建者 /// Creator类声明了要返回的工厂方法 /// &lt;/summary&gt; abstract class Creator &#123; //Product类的对象。创建者的子类通常提供此方法的实现。 public abstract IProduct FactoryMethod(); public string SomeOperation() &#123; var product = FactoryMethod(); var str = \"使用同一创建者代码执行\" + product.Operation(); return str; &#125; &#125; class CreatorA : Creator &#123; public override IProduct FactoryMethod() &#123; return new ProductA(); &#125; &#125; class CreatorB : Creator &#123; public override IProduct FactoryMethod() &#123; return new ProductB(); &#125; &#125; /// &lt;summary&gt; /// 产品接口 /// &lt;/summary&gt; public interface IProduct &#123; string Operation(); &#125; /// &lt;summary&gt; /// 产品A实现的是 1+2 /// &lt;/summary&gt; class ProductA : IProduct &#123; public string Operation() &#123; return \"产品A的操作是 1+2\"; &#125; &#125; /// &lt;summary&gt; /// 产品B实现的是 1*2 /// &lt;/summary&gt; class ProductB : IProduct &#123; public string Operation() &#123; return \"产品B的操作 1*2\"; &#125; &#125;&#125;12345678910111213class Program&#123; static void Main(string[] args) &#123; CreatorA creatorA = new CreatorA(); Console.WriteLine(creatorA.SomeOperation()); CreatorB creatorB = new CreatorB(); Console.WriteLine(creatorB.SomeOperation()); Console.ReadLine(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.ljchengx.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"工厂","slug":"工厂","permalink":"http://www.ljchengx.cn/tags/%E5%B7%A5%E5%8E%82/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.ljchengx.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"C#高级特性（泛型）","slug":"C-高级特性之泛型","date":"2020-09-28T16:00:00.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/09/29/C-高级特性之泛型/","link":"","permalink":"http://www.ljchengx.cn/2020/09/29/C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"一、什么是泛型泛型（Generic） 允许延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许编写一个可以与任何数据类型一起工作的类或方法。通过数据类型的替代参数编写类或方法的规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。特性有助于最大限度地重用代码、保护类型的安全以及提高性能。创建泛型集合类。.NET 框架类库在 System.Collections.Generic 命名空间中包含了一些新的泛型集合类。使用这些泛型集合类来替代 System.Collections 中的集合类。创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。对泛型类进行约束以访问特定数据类型的方法。关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。二、为什么要使用泛型1.案例创建一个简单类具有三个方法，参数分别对应三种不同数据类型。123456789101112131415161718/// &lt;summary&gt; /// 多类型示例方法 /// &lt;/summary&gt; class DemoMethod &#123; public void ShowInt(int iP) &#123; Console.WriteLine(\"传入的是：\" + iP + \"类型是：\" +iP.GetType()); &#125; public void ShowString(string sP) &#123; Console.WriteLine(\"传入的是：\" + sP + \"类型是：\" +sP.GetType()); &#125; public void ShowDatetime(DateTime dtP) &#123; Console.WriteLine(\"传入的是：\" + dtP + \"类型是：\"+dtP.GetType()); &#125; &#125;第二步在主程序中初始化参数来进行调用，有如下结果：OK 让我们回到方法本身，可以看到除了传入参数不同以外，内部实现完全一致，那我们是不是可以进行一波优化？来看下面：我们知道object是一切类型的父类，并且任何父类出现的地方都可以用其子类代替。了解这个情况那我们来改进其中的方法：123public void ShowObject(object oP) &#123; Console.WriteLine(\"传入的是：\" + oP + \"类型是：\" + oP.GetType());&#125;执行效果如下：根据结果看到确实达到了我们的需求，那既然这样的话我们还可以在继续延伸一下，这里问个大家问题 object类型有没有缺点？对当然有缺点了，来，我们看下面：装箱拆箱装箱：当传入一个int值时，在栈上，object又在堆上，就会把int值copy到堆里；拆箱：当使用int值时，又copy到栈里损耗程序的性能类型安全问题，传递的对象没有限制针对以上问题，微软在C#2.0的时候推出了泛型。三、如何使用泛型上面的object方法可以修改为以下形式：123public void ShowT&lt;T&gt;(T t) &#123; Console.WriteLine(&quot;传入的是：&quot; + t + &quot;类型是：&quot; + t.GetType());&#125;T为泛型的类型参数，但在代码中指定T的具体类型时，泛型中的所有T都替换为具体的类型。主方法中执行结果如下：泛型声明方法时，一开始没有确定类型，T是什么都不清楚；T要等调用的时候才能去确定；正是因为没有定死，才有无限可能；设计思想–延迟加载：例如分布式缓存队列、EF的延迟加载；上面使用泛型的是方法，同样类也是可以使用的泛型的，比如：1234class DemoClass&lt;T&gt;&#123; public T t;&#125;主函数使用：还有泛型接口：1234567namespace DemoOne&#123; interface DemoInterface&lt;T&gt; &#123; T getT(T t); &#125;&#125;泛型委托：1234567namespace DemoOne&#123; class Demodelegate &#123; public delegate void HellowWord&lt;T&gt;(T t); &#125;&#125;四、泛型的约束表格来至微软官方文档C#的值类型：整型:Int; 长整型:long; 浮点型:float; 字符型:char; 布尔型:bool;枚举:enum; 结构:struct; 在C#中所有的值类型都继承自:System.ValueTypeC#引用类型：数组、委托、接口、object、字符bai串、用户定义的类。约束描述where T：结构类型参数必须是值类型。 可以指定除 Nullable 以外的任何值类型。where T：类类型参数必须是引用类型；这同样适用于所有类、接口、委托或数组类型。where T：new()类型参数必须具有公共无参数构造函数。 与其他约束一起使用时，new() 约束必须最后指定。where T：&lt;基类名称&gt;类型参数必须是指定的基类或派生自指定的基类。where T：&lt;接口名称&gt;类型参数必须是指定的接口或实现指定的接口。 可指定多个接口约束。 约束接口也可以是泛型。where T：U为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。下面通过几个简单的例子来看下具体的约束：123456789public class Person&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Hellow() &#123; Console.WriteLine(\"Hellow\"); &#125; &#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// &lt;summary&gt;/// 值类型类型约束 /// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"t\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static T Get&lt;T&gt;(T t) where T : struct&#123; return t;&#125;/// &lt;summary&gt;/// 引用类型约束/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"t\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static T GetClass&lt;T&gt;(T t) where T : class&#123; return t;&#125;/// &lt;summary&gt;/// new()约束/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"t\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static T GetNew&lt;T&gt;(T t) where T : new()&#123; return t;&#125;/// &lt;summary&gt;/// 基类约束 约束类T必须是定义的Person或者其子类/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"t\"&gt;&lt;/param&gt;public static void Show&lt;T&gt;(T t) where T : Person&#123; Console.WriteLine($\"&#123;t.Id&#125;_&#123;t.Name&#125;\"); t.Hellow();&#125;/// &lt;summary&gt;/// 接口约束/// &lt;/summary&gt;/// &lt;typeparam name=\"T\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"a\"&gt;&lt;/param&gt;/// &lt;param name=\"b\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static T Max&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;&#123; return a.CompareTo(b) &gt; 0 ? a : b;&#125;注意：有多个泛型约束时，new()约束一定是在最后。五、泛型的协变和逆变协变和逆变是在.NET 4.0的时候出现的，只能放在接口或者委托的泛型参数前面，out 协变covariant，用来修饰返回值；in：逆变contravariant，用来修饰传入参数。先看下面的一个例子（部分用例和图片转自如下引用 如有侵权请联系本人删除）：cnblogs.com/VVStudy/p/11404300.html123456789101112interface IFoo&lt;out T&gt; &#123; T GetName(); &#125; class Foo : IFoo&lt;string&gt; &#123; public string GetName() &#123; return GetType().Name; &#125; &#125;主函数：1234 IFoo&lt;string&gt; fooStr = new Foo();IFoo&lt;object&gt; fooObj = fooStr;object name = fooObj.GetName();一图胜千言：1234567891011interface IBar&lt;in T&gt; &#123; void Print(T t);&#125;class Bar : IBar&lt;object&gt;&#123; public void Print(object t) &#123; Console.WriteLine(t); &#125;&#125;1234IBar&lt;object&gt; barObj &#x3D; new Bar();IBar&lt;string&gt; barStr &#x3D; barObj;barStr.Print(&quot;hellow word&quot;);涉及小问题：协变、逆变 为什么只能针对泛型接口或者委托？而不能针对泛型类？因为它们都只能定义方法成员（接口不能定义字段），而方法成员在创建对象的时候是不涉及到对象内存分配的，所以它们是类型（内存）安全的。为什么不针对泛型？因为泛型类是模板类，而类成员是包含字段的，不同类型的字段是影响对象内存分配的，没有派生关系的类型它们是不兼容的，也是内存不安全的。协变、逆变 为什么是类型安全的？本质上是里氏替换原则，由里氏替换原则可知：派生程度小的是派生程度大的子集，所以子类替换父类的位置整个程序功能都不会发生改变。自此关于C#泛型介绍到这里，针对部分问题还需认真思考，多去琢磨。","categories":[{"name":"C#高级特性","slug":"C-高级特性","permalink":"http://www.ljchengx.cn/categories/C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"泛型 特性 高级","slug":"泛型-特性-高级","permalink":"http://www.ljchengx.cn/tags/%E6%B3%9B%E5%9E%8B-%E7%89%B9%E6%80%A7-%E9%AB%98%E7%BA%A7/"}]},{"title":"项目质量管理ITTO","slug":"项目质量管理ITTO","date":"2020-09-24T06:49:23.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/09/24/项目质量管理ITTO/","link":"","permalink":"http://www.ljchengx.cn/2020/09/24/%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86ITTO/","excerpt":"","text":"项目质量管理ITTO规划质量管理输入：项目管理计划 干系人登记册 风险登记册 需求文件 事因 组资输出：质量管理计划 过程改进计划 质量测量指标 质量核对单 项目文件更新例如客户说这个产品只是要某某功能，那就质量规划也围绕这个来，即用到【干系人登记册）；质量好不好影响好售后，这是钱的问题，很重要，要考虑风险分析【风险登记册），最后看看【需求文件）有没有遗漏的地方，定出一个计划（质量管理计划】，和怎么测量质量好坏的指标（质量测量指标】，网上下载一份本行业的（质量核对单】来核对质量，再提出一个（过程改进计划】，过程改进是基于一些专家提出的观点而诞生的，大致意思就是检查是临时抱佛脚，是事后行为，只有在一开始和做事情的过程中就规范好。实施质量保证输入：质量管理计划 过程改进计划 质量测量指标 质量控制测量结果 项目文件输出：变更请求 项目管理计划更新 项目文件更新 组资更新保证工作质量。比对工作、产品质量结果和指标保证过程没有质量问题，拿【质量测量指标），还包括产品质量的测量结果【质量控制测量结果）一对比检查，就知道工作情况了。手里拿着过程改进计划，只要提出修改（变更请求】就好了控制质量输入：项目管理计划 质量测量指标 质量核对单 工作绩效数据 批准的变更请求 可交付成果 项目文件 组资输出：质量控制测量结果 确认的变更 核实的可交付物 工作绩效信息 变更请求 项目管理计划更新 项目文件更新 组资更新确认产品质量，确认产品变更。监控质量结果即产品有没有到达质量和按变更改好了。拿由控制时间、范围和成本输出的【工作绩效测量结果），和基准【质量测量指标）、【质量核对单）一起去检查分析产品【可交付成果）质量如何，得到一个文档即（质量控制测量结果】，同时确认产品是否达到质量要求，达到就是确认了产品（核实的可交付成果】，没有达到就提出修改意见（变更请求】；再使用变更控制委员会上【批准的变更）去检查产品是否按要求改了，如果改了，就确认这个修改（确认的变更】","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"ITTO","slug":"ITTO","permalink":"http://www.ljchengx.cn/tags/ITTO/"}]},{"title":"项目成本管理ITTO","slug":"项目成本管理ITTO","date":"2020-09-24T06:26:11.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/09/24/项目成本管理ITTO/","link":"","permalink":"http://www.ljchengx.cn/2020/09/24/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86ITTO/","excerpt":"","text":"项目成本管理ITTO规划成本管理输入：项目管理计划 章程 事因 组资输出：成本管理计划估算成本输入：成本管理计划 人力资源管理计划 范围基准 项目进度计划 风险登记册 事因 组织输出：活动成本估算 估算依据 项目文件更新参考进度、人力、风险，在范围工作包上大概算算花费。既然是大概算算，那就不用从活动这么细来算，从【范围基准）里面的WBS工作包开始估算就可以了，时间急不急【进度计划）、人手够不够【人力资源计划），风险带来损失【风险登记册）都会影响到成本估计，未来包括质量和采购出了风险就会导致损失，以后都要考虑风险的，但是时间和范围不用考虑风险，为什么呢，时间和范围受客户合同影响是死的，最后得到（活动成本估算】，这并不意味着基于活动的估算哦，是基于工作包的估算。还要有个备注（估算依据】，否则老板不知道钱为什么要这样花。制定预算输入：成本管理计划 范围基准 活动成本估算 估算依据 项目进度计划 资源日历 风险登记册 协议 组资输出：成本基准 资金需求 项目文件更新参考范围、日历，在进度计划上汇总成本曲线。首先把【活动成本估算）拿来，（估算依据】仍然要备给老板看，再参考采购【合同）上进货花的钱，成本汇总加起来得到一个总数，光有总数还不够，还要分配到各个阶段上去，如何做呢？【进度计划）里面不就定义了里程碑吗，直接填到里面就一目了然了，设计到钱的问题不能马虎，反复查查范围有没变【范围基准）和人有没时间【资源日历），做到天时地利人和，这样就得到一个曲线（成本绩效基准】和一个阶梯线（项目资金需求】，即做这个项目一共要多少钱，每个阶段用多少钱。控制成本输入：项目管理计划 资金需求 工作绩效数据 组资输出：工作绩效信息 成本预测 变更请求 项目管理计划更新 项目文件更新 组资更新比对工作和绩效考核花费。同理控制进度和控制范围，拿每天收集的工作情况【工作绩效数据）和预算中的【项目资金需求）和“成本绩效基准”一比较就可以得出花钱工作做的如何了，怎么看不到“成本绩效基准”，原来藏在“项目管理计划”里面。最后得到工作效果（工作绩效信息】，还有在工作进展到这个时间点上预测一下未来阶段成本（成本预测】，另外发现问题要提出修改（变更请求】。","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"ITTO","slug":"ITTO","permalink":"http://www.ljchengx.cn/tags/ITTO/"}]},{"title":"项目范围管理ITTO","slug":"项目范围管理ITTO","date":"2020-08-24T12:08:31.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/08/24/项目范围管理ITTO/","link":"","permalink":"http://www.ljchengx.cn/2020/08/24/%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86ITTO/","excerpt":"","text":"范围管理ITTO1.规划范围管理描述：管理范围 管理需求输入：项目管理计划 项目章程 事因 组资输出：范围管理计划 需求管理计划2.收集需求描述：记录需求 管理需求输入：范围管理计划 需求管理计划 干系人管理计划 项目章程 干系人登记册输出：需求文件 需求跟踪矩阵3.定义范围描述：明确项目边界输入：范围管理计划 需求文件 项目章程 组资输出：项目范围说明书 项目文件更新4.创建WBS描述： 目标，可交付物分解 项目工作的分解输入： 范围管理计划 项目范围说明书 需求文件 组资输出： 范围基准(批准的项目范围说明书 wbs wbs词典) 项目文件更新5.确认范围描述： 可交付成果的正式验收输入： 项目管理计划 需求文件 需求跟踪矩阵 核实的可交付成果 工作绩效数据输出： 验收的可交付成果 变更请求 工作绩效信息 项目文件更新6.控制范围描述： 监督范围状态 管理范围变更输入： 项目管理计划 需求文件 需求跟踪矩阵 工作绩效数据 组资输出： 工作绩效信息 变更请求 项目管理计划更新 项目文件更新 组资更新范围管理就是管理做哪些事情。为了便于区分输入输出，是【）代表输入，（】代表输出，【】代表过程，（）代表技术工具【规划范围管理】：项目一开始肯定不知道要做什么，怎么做，首先要制定两个计划来做管理的依据，一个是（范围管理计划】另一个是（需求管理计划】，主要是想好怎么管理范围和需求，方法和编写的的依据直接看【项目管理计划）和【章程），不行的话看看【事因）和【组资）都是可以的。【收集需求】：拿着【范围管理计划），【干系人管理计划）和【需求管理计划）找客户收需求，记跟踪。首先要找到相关人包括客户、投资人【干系人登记册）来了解需求，由于人太多，让相关人了解项目大概是什么最快办法就是让他们自己看【项目章程），然后得到他们的需求了，记在（需求文件】里面，为了不浪费太多时间，同时把如何跟踪需求（需求跟踪矩阵】也做好了。【定义范围】：第二步就是定义项目的边界了，按照【项目管理计划）的要求同时【项目章程）本来就提了点项目大概要做什么，就对照【需求文件）直接在上面改，省时省力，同时看看【组资）可有借鉴的地方，一下子就加工成一个文档了（项目范围说明书】，酷！【创建WBS】：然后就是细分事情，创建WBS，对照【需求文件）拿【项目范围说明书）开刀，你要什么我就给你分什么，最后分解成（WBS】和（WBS词典】，然后把项目范围说明书、WBS和WBS词典一起装订起来又成了一个新重要基准文档（范围基准】，竟然可以这样写文档，真可谓天下文章一大抄啊。【确认范围】：下一步是核实做的事情结果是否在工作范围之内，首先要通过【需求跟踪矩阵）去保持和提出需求的人的联系，确定工作范围有没有变，然后对照【需求文档）去核实做的事情【核实的可交付成果）的范围了，核实没有问题的话就可以验收这个事情了（验收的可交付成果】，有问题就产生一个（变更请求】，同时根据这期间的【工作绩效数据）生成新的（工作绩效信息】。【控制范围】：控制范围是控制做的事情过程是否在工作范围之内，首先还是要通过【需求跟踪矩阵）去保持和提出需求的人的联系，确定工作范围有没有变。既然是控制过程本身，那就要用到每日收集的工作状况【工作绩效信息），再对照【需求文件）得到工作做出的效果如何（项目绩效信息】，有问题就产生一个（变更请求】，同时把（项目管理计划】，（项目文件】，（组资】更新下。从技术工具层面上说，收集需求要面对那么多人，自然少不了方法，人不多可以访谈，多了点就分焦点小组，意见不同意引导研讨一下，人再多就发挥群体创新和决策能力，人再再多就问卷调查了，遇到有些人不太爱说就观察，说不清楚的干脆做个模型出来看看定义范围就是定义要做的事情，也就是最终产品就是这样了，所以好方法应该是找个现在市面上类似的产品分析一下，简单高效，分析的时候要多用点备选方案来识别，保险起见，再开个引导式研讨会，请客户一起来分析创建WBS就是分解，一层层分解到活动核实范围是查东西好不好，就是拿着最终东西翻来覆去的检查控制范围是查过程好不好，进行偏差分析，来工作绩效信息和需求文档一一比较是否有偏差","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"ITTO","slug":"ITTO","permalink":"http://www.ljchengx.cn/tags/ITTO/"}]},{"title":"Jenkins参数化构建Android项目支持上传蒲公英","slug":"Jenkins参数化构建Android项目支持上传蒲公英","date":"2020-07-23T12:20:12.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/07/23/Jenkins参数化构建Android项目支持上传蒲公英/","link":"","permalink":"http://www.ljchengx.cn/2020/07/23/Jenkins%E5%8F%82%E6%95%B0%E5%8C%96%E6%9E%84%E5%BB%BAAndroid%E9%A1%B9%E7%9B%AE%E6%94%AF%E6%8C%81%E4%B8%8A%E4%BC%A0%E8%92%B2%E5%85%AC%E8%8B%B1/","excerpt":"","text":"一、新建一个自由风格的任务，进入配置项 General选择参数化构建过程1.新增选择选项参数BUILD_TYPE 设置debug release2.添加字符参数APP_VERSION_NAME APP_VERSION_CODE IS_JENKINS 如下图3.项目代码调整这里设置后如何在项目代码中使用，我们需要在项目的gradle.properties文件下新增刚才添加的参数1BUILD_TYPE APP_VERSION_NAME APP_VERSION_CODE IS_JENKINS然后修改app下的build.gradle来使用这些参数 例如：123456defaultConfig &#123; minSdkVersion 19 targetSdkVersion 29 versionCode APP_VERSION_CODE as int versionName APP_VERSION_NAME &#125;回到Jenkins下构建命令修改成使用参数的形式 assemble${BUILD_TYPE}，展开勾选Pass all job parameters as Project properties保存完成，开始打包。二、打包完成自动上传蒲公英1.安装蒲公英插件前往插件管理，搜索 Upload to pgyer 完成安装。2.增加构建后操作步骤 新增归档成品地址填写自己的打包后的地址(方便执行完成后 可以展示出apk)app/build/outputs/apk/${BUILD_TYPE}/*.apk3.新增upload to pgyer with apiV1两个Key根据自己的账号填写${WORKSPACE}/app/build/outputs/apk/${BUILD_TYPE}app-${BUILD_TYPE}.apk4.展示蒲公英下载二维码安装插件description setter plugin回到增加构建后步骤 set build description填写如下信息：1&lt;a href&#x3D;&quot;$&#123;appBuildURL&#125;&quot;&gt;&lt;img src&#x3D;&quot;$&#123;appQRCodeURL&#125;&quot; width&#x3D;&quot;118px&quot; height&#x3D;&quot;118px&quot;&gt;&lt;&#x2F;a&gt;保存后进入首页系统管理的全局安全管理 修改格式器为safe html 保存，然后重新打包项目。打包完成后就能在界面看见下载二维码和构建结果。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/categories/Android/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.ljchengx.cn/tags/jenkins/"}]},{"title":"Liunx服务器部署Jenkins打包Android Apk","slug":"Liunx服务器部署Jenkins打包AndroidApk","date":"2020-07-21T12:20:12.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/07/21/Liunx服务器部署Jenkins打包AndroidApk/","link":"","permalink":"http://www.ljchengx.cn/2020/07/21/Liunx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Jenkins%E6%89%93%E5%8C%85AndroidApk/","excerpt":"","text":"Liunx服务器部署Jenkins打包Android Apk一.安装JAVA环境1.下载JDK​ 根据情况下载JDK版本 目前本教程使用的jdk8 也可以自行前往下载页面: https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html. 这里要看下自己的服务器系统是32位还是64位，按照所需下载即可，建议下载后缀为tar.gz压缩格式的安装包。下载后上传到服务器上，通过命令 tar -zxvf jdk-8u261-linux-i586.tar.gz 即可。2.配置环境变量1vim &#x2F;etc&#x2F;profile打开到最后加上JAVA_HOME环境变量123export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_261export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libexport PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH执行命令使环境变量生效1source &#x2F;etc&#x2F;profile二.安装GRADLE环境1.下载GRADLE​ 根据项目中使用的gradle版本下载对应文件 下载地址:https://services.gradle.org/distributions/这里使用的是 gradle-5.4.1-all.zip，下载后上传到服务器 这里放的是/usr/local/gradle 路径下(根据自己的情况来)，解压 。1unzip gradle-5.4.1-all.zip2.配置环境变量打开文件1vim &#x2F;etc&#x2F;profile文件最后加上(可以和JAVA_HOME放一起)12export GRADLE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;gradle&#x2F;gradle-5.4.1export PATH&#x3D;$&#123;GRADLE_HOME&#125;&#x2F;bin:$&#123;PATH&#125;然后执行生效1source &#x2F;etc&#x2F;profile三.安装AndroidSDK1.下载AndroidSDK​ 打开网址：https://developer.android.google.cn/studio找到Command line tools only 标题下的SDK tools package 下载Linux包下载完成后上传服务器 /opt/android(路径根据自己情况来 可以和gradle放一起)。完成解压 unzip xxx正常解压后只有这一个文件夹，OK 我们这个时候先去配置下环境打开1vim &#x2F;etc&#x2F;profile和上面一样12export ANDROID_HOME&#x3D;&#x2F;opt&#x2F;android&#x2F;sdkexport PATH&#x3D;$PATH:$ANDROID_HOME:$ANDROID_HOME&#x2F;tools:$ANDROID_HOME&#x2F;platform-tools:$ANDROID_HOME&#x2F;tools&#x2F;bin配置Android_home执行1source &#x2F;etc&#x2F;profile这个时候来到刚才只有tools这一层文件夹执行1sdkmanager --list应该会出现下图这样的表格这个时候就根据当前项目需要的版本来进行安装就可以。比如当前项目需要 build-tools:29.0.2 ，platforms;android-28 ，ndk;21.3.6528147例如执行：1234sdkmanager &quot;platform-tools&quot;sdkmanager &quot;build-tools:29.0.2&quot;sdkmanager &quot;platforms;android-28&quot;sdkmanager &quot;ndk;21.3.6528147&quot;等需要的版本都安装好以后当前文件夹下就会出现如上面那个图。到此需要的环境变量全部安装完成。四.安装Jenkins1.下载安装包​ 前往：http://pkg.jenkins-ci.org/redhat-stable/ 例如下载：jenkins-2.222.1-1.1.noarch.rpm 上传到服务器上1rpm -ivh jenkins-2.222.1-1.1.noarch.rpm完成安装。2.修改配置1vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins可以根据自己的需要改变端口，原来的是8080 。基本上安装完成了可以访问下服务器ip:8080是不是通了，如果没有通查看问题1systemctl status jenkins如果是java环境问题可以替换自己的路径修改java配置： vi /etc/init.d/jenkins 修改为自己java路径然后启动service jenkins start第一次打来jenkins的时候，有个初始化密码，需要你输入。密码在服务器的 cd /var/lib/jenkins/secrets五.开始打包1.打开jenkins系统管理下的系统配置，完成以下三个参数的配置ANDROID_HOME/usr/share/android-sdkGRADLE_USER_HOME/usr/local/gradle/gradle-5.4.1JAVA_HOME/usr/local/java/jdk1.8.0_261这三个路径在上面服务器的环境变量里保持一致2.安装Gradle插件 成功后进入系统管理的全局工具配置这里地址也是上面服务器的环境变量配置。3.新建一个任务源码管理根据自己的需要 默认有git没有svn的去插件管理安装下subversion然后新增构建步骤1位置选择刚才设置的全局参数 2位置选择你的执行命令 可以空格分开点击保存回到首页就可以构建了。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/categories/Android/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.ljchengx.cn/tags/jenkins/"}]},{"title":"旋转数组","slug":"旋转数组","date":"2020-07-18T07:39:59.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/07/18/旋转数组/","link":"","permalink":"http://www.ljchengx.cn/2020/07/18/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。示例 1:123456输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]解法：1234567891011121314class Solution &#123; public void rotate(int[] nums, int k) &#123; int index = 0; for (int j = 0; j &lt; k; j++) &#123; index = nums[nums.length - 1]; for (int i = nums.length-1; i &gt; 0; i--) &#123; nums[i] = nums[i-1]; &#125; nums[0] = index; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.ljchengx.cn/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.ljchengx.cn/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"删除排序数组中的重复项","slug":"删除排序数组中的重复项","date":"2020-07-18T07:30:26.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/07/18/删除排序数组中的重复项/","link":"","permalink":"http://www.ljchengx.cn/2020/07/18/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"删除排序数组中的重复项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例 1:12345给定数组 nums &#x3D; [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。解法：123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i +1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.ljchengx.cn/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.ljchengx.cn/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"记一次关于LitePal数据库的使用","slug":"记一次关于LitePal数据库的使用","date":"2020-03-28T05:58:19.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/03/28/记一次关于LitePal数据库的使用/","link":"","permalink":"http://www.ljchengx.cn/2020/03/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ELitePal%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.原因描述：项目过程中需要使用本地数据库来保存一些临时数据，方便下次读取使用。发现了LitePal这个库，于是记录下使用的过程，LitePal这个库是郭霖大神写的,下面就是集成知识简单的使用,如果有什么不对的地方望指出。2.尝试方法：2.1 LitePal库的集成1implementation 'org.litepal.android:java:3.0.0'2.2 创建litepal.xml文件在你的项目assets 下添加litepal.xml 这一步主要的是完成数据库相关配置 如名称，版本和表。2.3 初始化数据库配置这里两种方式第一个是让你的AndroidManifest.xml 直接使用org.litepal.LitePalApplication 或者在你自己的Application中加上 LitePal.initialize(this);2.4 建表这里注意新增的表一定要在litepal.xml文件的list下面添加才可以。2.5 插入数据1234567891011121314public void insert(View view) &#123; ExampleModel exampleModel = new ExampleModel(); exampleModel.setKey(\"123\"); exampleModel.setContent(\"456\"); exampleModel.saveAsync().listen(new SaveCallback() &#123; @Override public void onFinish(boolean success) &#123; if(success)&#123; Toast.makeText(MainActivity.this, \"数据库保存成功\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;);&#125;这里使用了异步保存的方法 也可以直接使用save()方法。2.6 查询数据123456789public void select(int id) &#123; //根据Id查询 ExampleModel exampleModel = LitePal.find(ExampleModel.class, id); //根据条件查询 List&lt;ExampleModel&gt; exampleModels = LitePal.where(\"key = ? \", \"123\").find(ExampleModel.class);&#125;不同的查询方式，还有更加详细的方式可以看看官方的文档。2.7 删除数据123456public void delete(int id)&#123; LitePal.delete(ExampleModel.class, id); LitePal.deleteAll(ExampleModel.class, \"key = ?\" , \"350\");&#125;5.参考链接：https://github.com/LitePalFramework/LitePal","categories":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/categories/Android/"}],"tags":[{"name":"LitePal","slug":"LitePal","permalink":"http://www.ljchengx.cn/tags/LitePal/"},{"name":"数据库","slug":"数据库","permalink":"http://www.ljchengx.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Android处理okhttp3请求添加公共参数","slug":"Android处理okhttp3请求添加公共参数","date":"2020-03-28T02:07:37.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/03/28/Android处理okhttp3请求添加公共参数/","link":"","permalink":"http://www.ljchengx.cn/2020/03/28/Android%E5%A4%84%E7%90%86okhttp3%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E5%85%AC%E5%85%B1%E5%8F%82%E6%95%B0/","excerpt":"","text":"1.问题描述：由于前期项目没有增加移动端接口相关埋点信息，于是现在需要在调用相关的接口做公共参数的发送，服务端可以根据这部分固定的参数来增加埋点信息的处理。2.解决思路：由于字段统一而且牵扯到的接口很多，如果一个一个处理的话工作量太大，而且后面如果新增接口还需要添加固定的这几个参数，如果牵扯修改的话，会更加麻烦。于是考虑okhttp3的拦截器去统一处理。3.遇到的问题：开始处理的方式是获取url通过addQueryParameter方式来添加上，然后发现效果不是想要的，这样的方式会把参数直接加到url后面，而不是我们希望的加到已有参数的后面。于是继续探究。4.解决方式：123456789101112131415161718192021222324252627282930/** * @ProjectName: trunk * @ClassName: urlInterceptor * @Description: okhttp3拦截器新增公共参数 * @Author: ljchengx * @CreateDate: 2020/3/26 17:41 */public class BodyInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBody = new FormBody.Builder(); FormBody oldFormBody = (FormBody) request.body(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add(\"equipmentModel\", Build.MODEL); newFormBody.add(\"equipmentApiVersion\", Build.VERSION.SDK_INT+\"\"); requestBuilder.method(request.method(), newFormBody.build()); &#125; Request newRequest = requestBuilder.build(); return chain.proceed(newRequest); &#125;&#125;5.参考链接：-","categories":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/categories/Android/"}],"tags":[{"name":"拦截器","slug":"拦截器","permalink":"http://www.ljchengx.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"公共参数","slug":"公共参数","permalink":"http://www.ljchengx.cn/tags/%E5%85%AC%E5%85%B1%E5%8F%82%E6%95%B0/"}]},{"title":"Android处理Cookie过期静默更新","slug":"Android处理Cookie过期静默更新","date":"2020-03-21T07:44:34.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/03/21/Android处理Cookie过期静默更新/","link":"","permalink":"http://www.ljchengx.cn/2020/03/21/Android%E5%A4%84%E7%90%86Cookie%E8%BF%87%E6%9C%9F%E9%9D%99%E9%BB%98%E6%9B%B4%E6%96%B0/","excerpt":"","text":"1.问题描述：​ 项目中在请求接口时在header上带上Cookie信息 一直没有处理过期时间，最近需要在原来的基础上添加请求Cookie过期后静默更新的功能。目前使用的是retrofit2+okhttp3+rxjava2的网络框架。2.解决思路：​ 因为添加Cookie使用的是Okhttp3的拦截器处理的方式 需要准备在之前的Interceptor上面改造，其实处理起来也不是很复杂，需要确定的思路是在请求是做统一拦截，根据和服务端约定好的规则来判断是否处理Cookie过期，如果过期之前需要在同步请求一个新的接口拿到最新的Cookie信息放到原来的请求上，重新完成请求。3.遇到的问题：需要和服务端协调好规则，如何判断失效，同时需要注意要重写一个新的请求4.解决方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class AddCookiesInterceptor implements Interceptor &#123; private Handler mHandler = new Handler(); private String resultStr; private Context context; public AddCookiesInterceptor(Context context) &#123; super(); this.context = context; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request.Builder builder = chain.request().newBuilder(); //这里使用本地存的cookie来添加到每个请求的header 方式有很多 如本地数据库保存 这里举一个例子 String cookie = CookieSp.get(); if (!TextUtils.isEmpty(cookie)) &#123; builder.addHeader(\"Cookie\", cookie); &#125; Request request = builder.build(); Response response = chain.proceed(request); //判断是否Cookie过期 if (isCookieExpired(response)) &#123; KLog.e(\"AddCookiesInterceptor\", \"无感刷新Cookie,然后重新请求数据\"); //同步请求方式，获取最新的Cookie String newCookie = getNewCookie(); KLog.e(\"AddCookiesInterceptor\", newCookie+\"新Cookie\"); //使用新的Cookie，创建新的请求 if (null != newCookie &amp;&amp; newCookie.length() &gt; 0) &#123; Request newRequest = chain.request() .newBuilder() .header(\"Cookie\", newCookie) .build(); //重新请求上次的接口 return chain.proceed(newRequest.newBuilder().build()); &#125; &#125; return chain.proceed(request); &#125; /** * 获取新的Cookie */ private String getNewCookie() &#123; //根据服务端约定好的新接口 获取新的Cookie String url = HttpConstant.BASE_URL + \"/api/login/newlogin?userName=123&amp;pwd=123\"; KLog.e(\"AddCookiesInterceptor\", \"重新请求---\" + url); //新建立一个请求 HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(); OkHttpClient client = new OkHttpClient.Builder() .hostnameVerifier(HttpsUtils.UnSafeHostnameVerifier) .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager) .connectionPool(new ConnectionPool(8, 10, TimeUnit.SECONDS)) .build(); Request request = new Request.Builder().url(url).build(); okhttp3.Call call = client.newCall(request); StringBuffer cookie = new StringBuffer(); try &#123; Response response = call.execute(); RequestCode data = new Gson().fromJson(response.body().string(), RequestCode.class); //这里根据约定好的规则获取新的Cookie 这里是根据头部信息拿到新的Cookie 保存在本地 if (data.getCode() == 1) &#123; if (!response.headers(\"Set-Cookie\").isEmpty()) &#123; List&lt;String&gt; list = response.headers(\"Set-Cookie\"); for (String str : list) &#123; cookie.append(str).append(\";\"); &#125; CookieSp.put(cookie.toString()); &#125; &#125; else &#123; KLog.e(\"AddCookiesInterceptor\", \"新Cookie获取失败---退出登录\" ); AppManager.getAppManager().finishAllActivity(); //这里处理你的退出重新登录的逻辑 &#125; &#125; catch (IOException e) &#123; KLog.e(\"AddCookiesInterceptor\",e.toString()); e.printStackTrace(); &#125; return cookie.toString(); &#125; /** * 根据返回值判断Cookie是否过期 */ private boolean isCookieExpired(Response response) &#123; try &#123; resultStr = response.body().string(); RequestCode requestCode = new Gson().fromJson(resultStr, RequestCode.class); KLog.e(\"AddCookiesInterceptor\", requestCode.getCode() + \"----requestCode\"); //根据服务端约定的规则来判断是否过期 if (requestCode.getCode() == -300) &#123; KLog.e(\"AddCookiesInterceptor\", \"----requestCode,Cookie登录过期了\"); return true; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125;5.参考链接：https://www.jianshu.com/p/66b59ad1fdc1","categories":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.ljchengx.cn/tags/Android/"},{"name":"Cookie","slug":"Cookie","permalink":"http://www.ljchengx.cn/tags/Cookie/"},{"name":"拦截器","slug":"拦截器","permalink":"http://www.ljchengx.cn/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"项目整合管理","slug":"项目整合管理","date":"2020-03-21T06:42:46.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/03/21/项目整合管理/","link":"","permalink":"http://www.ljchengx.cn/2020/03/21/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E7%AE%A1%E7%90%86/","excerpt":"","text":"项目整合管理整合管理包括对隶属于项目管理过程组的各种过程和项目管理活动进行识别、定义、组合、统一和协调的各个过程。 在项目管理中，整合兼具统一、合并、沟通和建立联系的性质，这些行动应该贯穿项目始终。","categories":[{"name":"PMP","slug":"PMP","permalink":"http://www.ljchengx.cn/categories/PMP/"}],"tags":[{"name":"项目整合","slug":"项目整合","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88/"}]},{"title":"项目经理角色","slug":"项目经理角色","date":"2020-03-21T06:19:36.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/03/21/项目经理角色/","link":"","permalink":"http://www.ljchengx.cn/2020/03/21/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%E8%A7%92%E8%89%B2/","excerpt":"","text":"项目经理角色项目经理的角色不同于职能经理和运营经理 项目经理是由执行组织委派，领导团队实现项目目标的个人。1. 项目经理的胜任力2. 领导力与管理之比较管理领导直接利用权力利用关系权力来指导 影响和合作维护发展管理创新关注系统和架构关注人际关系依赖控制激发信任关注近期目标关注长期愿景了解方式和时间了解情况和原因关注赢利关注前景接受现状挑战现状正确的做事做正确的事关注操作层面的问题及解决关注愿景一致性 动力和激励3. 项目经理多种领导力风格放任型领导 允许团队自主决策和设定目标 又被称为甩手型交易型领导 根据目标、反馈和成就给予奖励服务型领导 做出服务承诺 处处先为他人着想 关注他人成长 学习 发展 关注人际关系 社区与合作 服务优先于领导变革型领导 通过理想化特质和行为 鼓励性激励 促进创新和改造 以及个人关怀提高追随者的能力魅力型领导 激励他人 精神饱满 热情洋溢 充满自信 说服力强交互型领导 结合了交易型 变革型 魅力型的特点","categories":[{"name":"PMP","slug":"PMP","permalink":"http://www.ljchengx.cn/categories/PMP/"}],"tags":[{"name":"项目经理","slug":"项目经理","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86/"}]},{"title":"2020年1月30日闲聊","slug":"2020年1月30日闲聊","date":"2020-01-30T05:47:58.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/30/2020年1月30日闲聊/","link":"","permalink":"http://www.ljchengx.cn/2020/01/30/2020%E5%B9%B41%E6%9C%8830%E6%97%A5%E9%97%B2%E8%81%8A/","excerpt":"","text":"2020年1月30日闲聊Chapter 1&ensp;&ensp;&ensp;&ensp;今天是2020年1月30日也是大年初六，本来今天按照往年的日程安排是踏上返程的一天，也是春节假期的最后一天，可是现在我却坐在家里，对着电脑写下这篇文章。&ensp;&ensp;&ensp;&ensp;时间回到放假的前一天，一月二十二日也就是腊月二十八，按照往常的时间在八点十分左右到了办公室，由于今天是放假前最后一天，有些同事请假回去了，此时办公室没有几个人，走到茶水间吃了顺路买的鸡蛋和热豆浆，然后开始烧水泡茶回到工位上。”叮咚”然后看了一眼手机，手机推送的一则消息，武汉的新型病毒感染有扩大趋势，大家返程需要做好防护措施。”我去，怎么突然变这么厉害”我抬头看了一眼边走到工位边吐槽的一位同事，然后和他闲聊了两句关于武汉疫情的消息。然后女朋友发了消息说赶紧买口罩，现在貌似买不到了，突然气氛就变的紧张起来了，然后群里公司老大发了消息今天坚守在工作岗位的同事，晚上她请大家吃火锅。&ensp;&ensp;&ensp;&ensp;回到现在，刚才走到客厅倒了杯水顺便看了一眼新闻，全国新型冠状病毒确诊人数已达7742人，然后走到厨房看到老妈在准备包饺子，听她说现在准备点饺子，后面就少出点门买东西了。&ensp;&ensp;&ensp;&ensp;。。。&ensp;&ensp;&ensp;&ensp;看了眼时间，还有3个多小时就下班了，大家都在准备工作的收尾工作，我和我们组的两位同事在讨论坐高铁回家的事情，然后一位同事说看现在这个情况坐高铁还是有点担心，于是他就直接取消了回家的高铁票，我们在讨论要不要这么担心，反正现在还没有波及到这边，同事说这两天刚刚发烧才好，身体抵抗力还是弱，准备找车子回去，不去人流密集地方。群里在统计晚上一起吃火锅的人数，但是看反应，貌似大家积极性也很低，整个办公室弥漫着紧张的氛围。Chapter 2&ensp;&ensp;&ensp;&ensp;今天已经是在家没出门的第六天的日子了。&ensp;&ensp;&ensp;&ensp;时间回到放假那天，早上我和我女朋友一起打车去高铁站，可以看到百分之60的人都戴了口罩，当然我们也戴了女朋友给我留了一袋，然后1个多小时后，当我回到老家县城的时候发现家里基本没有人戴口罩，连疫情宣传都没有。在我回来的第二天，武汉全面封城，随后全国各地启动突发公共卫生事件一级响应。年30上午我出门去买了对联，然后我女朋友发信息让我去看看还能不能买到口罩，然后我去药店发现买的人挺多，但是货源也是挺充足的，于是我买了比较难买的N95的和普通的医用口罩。&ensp;&ensp;&ensp;&ensp;一月二十七日，国家发布通知延长春节假期至二月二号，多了三天假期，看了新闻安徽这边发生了聚集性疫情，于是就宅在家里，哪里也不出去了，就在家新闻，截至今天，西藏也出现一例确诊病例，这下真的是全国各地都有病例了，目前确诊7742，疑似12167，死亡170。早上起来接到信息公司延长假期至二月十号，现在坐在电脑敲下这些天的经历，真是唏嘘不已。&ensp;&ensp;&ensp;&ensp;希望武汉这次能挺住，希望国家挺住，全国一起加油克服疫情！","categories":[{"name":"日记","slug":"日记","permalink":"http://www.ljchengx.cn/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://www.ljchengx.cn/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"C#异步Task","slug":"C-异步Task","date":"2020-01-21T06:22:46.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/C-异步Task/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/C-%E5%BC%82%E6%AD%A5Task/","excerpt":"","text":"目前项目中使用最多的两种异步Task以下方式是在项目中 主要处理服务事件的多线程异步方案主要完成的单个服务 变成异步多线程 提升效率的写法 可以给需要的朋友提供一下思路第一种是一个轮询服务，主要涉及一些定时的任务、轮询处理的问题，可以自己定义阀门和时间点关于轮询异步Task1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace ConsoleApplication5&#123; class Program &#123; public static bool _go = true; public static int currentTeacherCount = 0; public static int maxTask = 15; public static object obj = new object(); public static bool _go_LogStastic = true; //阀门 //轮询的多线程 static void Main(string[] args) &#123; while (_go) &#123; if (_go_LogStastic) &#123; _go_LogStastic = false; var task = new Task(delegate() &#123; Log(\"1\"); &#125;); task.Start(); task.ContinueWith(q =&gt; &#123; _go_LogStastic = true; &#125;); &#125; &#125; Console.WriteLine(\"所有线程结束！\"); Console.ReadLine(); &#125; public static void Log(String str) &#123; Console.WriteLine(\"开始处理第\" + str + \"个\"); &#125; &#125;&#125;第二种是循环的情景，主要有单一处理方案但是总数据过多，需要嵌套循环处理的方式。可以根据当前环境设定最大线程数来控制，并且支持原子计数，方便日志打印进行跟踪。关于循环异步Task12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace ConsoleApplication5&#123; class Program &#123; public static bool _go = true; public static int currentTeacherCount = 0; public static int maxTask = 15; public static object obj = new object(); static void Main(string[] args) &#123; List&lt;Task&gt; tasks = new List&lt;Task&gt;(); List&lt;String&gt; list = new List&lt;string&gt;(); list.Add(\"1\"); list.Add(\"2\"); list.Add(\"3\"); list.Add(\"4\"); foreach (var item in list) &#123; tasks.Add(Task.Factory.StartNew(() =&gt; &#123; Log(item); &#125;).ContinueWith(t =&gt; &#123; lock (obj) &#123; Interlocked.Increment(ref currentTeacherCount); Console.WriteLine(\"第\" + currentTeacherCount + \"数据同步完成,共\" + list.Count() + \"数据需要处理\"); &#125; &#125;)); if (tasks.Count &gt;= maxTask) &#123; Task.WaitAny(tasks.ToArray()); tasks = tasks.Where(t =&gt; t.Status == TaskStatus.Running).ToList(); &#125; &#125; Task.WaitAll(tasks.ToArray()); Console.WriteLine(\"所有线程结束！\"); Console.ReadLine(); &#125; public static void Log(String str) &#123; Console.WriteLine(\"开始处理第\" + str + \"个\"); &#125; &#125;&#125;","categories":[{"name":"C#","slug":"C","permalink":"http://www.ljchengx.cn/categories/C/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://www.ljchengx.cn/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-01-21T06:11:53.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/单例模式/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是设计模式？设计模式的六大原则是什么？设计模式的分类？什么是单例模式？单例模式常见的7种实现方式及优缺点懒汉式懒汉式（线程安全）双重检测机制饿汉式静态块实现静态内部类实现枚举序列化对单例模式的影响单例模式引起内存泄漏的解决方案什么是设计模式？那现在正式开始今天的分享，设计模式这个词大家应该都不陌生啊，在写代码的时候很多人都会运用到设计模式。那什么是设计模式呢。设计模式（Design pattern）是一套被反复使用、多数人知晓的、是代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式的目标之一就是提高程序的可复用性。考虑的是怎样才能将程序作为“组件”复用。设计模式的六大原则是什么？开闭原则（Open Close Principle）：对扩展开放，对修改关闭里氏替换原则（Liskov Substitution Principle）：子类可以扩展父类的功能，但不能改变父类原有的功能依赖倒转原则（Dependence Inversion Principle）：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象，核心思想是面向接口编程接口隔离原则（Interface Segregation Principle）：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。迪米特法则（最少知道原则）（Demeter Principle）：一个对象应该对其他对象保持最少的了解单一职责原则（ Single responsibility principle ）：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。设计模式的分类GOF设计模式分类：23种创建型设计模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。工厂方法模式（Factory Method）抽象工厂模式（Abstract Factory）创建者模式（Builder）原型模式（Prototype）单例模式（Singleton）结构型模式：描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。外观模式/门面模式（Facade门面模式）适配器模式（Adapter）代理模式（Proxy）装饰模式（Decorator）桥梁模式/桥接模式（Bridge）组合模式（Composite）享元模式（Flyweight）行为型设计模式：是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用模板方法模式（Template Method）观察者模式（Observer）状态模式（State）策略模式（Strategy）职责链模式（Chain of Responsibility）命令模式（Command）访问者模式（Visitor）调停者模式（Mediator）备忘录模式（Memento）迭代器模式（Iterator）解释器模式（Interpreter）什么是单例模式？程序在运行的时候，通常都会生成多个实例，例如表示字符串的java.lang.String类的实例与字符串是一对一的关系，所以当有一千个字符串的时候，就会生成1000个实例，许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。(维基百科)。总结为确保任何情况下都绝对只有一个实例。或者想在程序上表现出“只存在一个实例”这就是单例模式。单例模式常见的7种实现方式及优缺点懒汉式线程不安全在单例模式中，有一种称为懒汉式的单例模式。顾名思义，懒汉式可以理解使用时才进行初始化，它包括私有的构造方法，私有的全局静态变量，公有的静态方法，是一种懒加载机制。123456789101112131415161718192021222324252627282930313233 /** 懒汉式线程不安全 */public class Singleton &#123; private static Singleton instance; private Singleton() &#123;​ System.out.println(\"初始化\"); &#125; public static Singleton getInstance() &#123;​ if (instance == null) &#123;​ instance = new Singleton();​ &#125;​ return instance; &#125;&#125;上面是最常见的懒汉式单例模式的写法，但是如果在多线程的情况下，上述方法就会出现问题，它达不到只有一个单例对象的效果，例如当某个线程1调getInstance（）方法并判断instance == null，此时（就在判断为空后new Singleton()之前）另一个线程2也调用getInstance（）方法，由于此时线程1还没有new出对象，则线程2执行getInstance（）中instance 也为空，那么此时就会出现多个实例的情况，而达不到只有一个实例的目的懒汉式（线程安全）在上述实现中我们提到的懒汉式单例模式是一种非线程安全的，非线程安全即多线程访问时会生成多个实例。那么怎么样实现线程安全呢，也许你应该已经想到使用同步关键字synchronized1234567891011121314151617181920212223242526272829303132333435363738/** \\* *2懒汉式线程安全： */public class Singleton &#123; private static Singleton instance; private Singleton() &#123;​ System.out.println(\"初始化\"); &#125; public static synchronized Singleton getInstance() &#123;​ if (instance == null) &#123;​ instance = new Singleton();​ &#125;​ return instance; &#125;&#125;使用同步关键字后，也就实现了线程安全访问，因为在任何时候它只能有一个线程调用 getInstance() 方法。那么你可能会发出疑问，这样加入同步，在高并发情况下，效率是很低的，因为真正需要同步的是我们第一次初始化的时候，是的，所以我们要进行进一步的优化。双重检测顾名思义就是两次检测，一次是检测instance 实例是否为空，进行第一次过滤，在同步快中进行第二次检测，因为当多个线程执行第一次检测通过后会同时进入同步快，那么此时就有必要进行第二次检测来避免生成多个实例。12345678910111213141516171819202122232425262728293031323334353637383940414243/** \\* *3DCL */public class DCLSingleton &#123; private static DCLSingleton instance; private DCLSingleton() &#123;​ System.out.println(\"初始化\"); &#125; public static synchronized DCLSingleton getInstance() &#123;​ if(instance==null)&#123;​ synchronized (DCLSingleton.class) &#123;​ if (instance == null) &#123;​ instance = new DCLSingleton();​ &#125;​ &#125;​ &#125;​ return instance; &#125;&#125;对于上面的代码时近乎完美的，既然说近乎完美，那肯定还是有瑕疵的，瑕疵出现的原因就是instance = new Singleton();这一句代码，你可能会问，这会有什么问题，其实我也不知道，哈哈。在计算机语言中，初始化包含了三个步骤分配内存执行构造方法初始化将对象指向分配的内存空间由于java编译器为了尽可能减少内存操作速度远慢于CPU运行速度所带来的CPU空置的影响，虚拟机会按照自己的一些规则(这规则后面再叙述)将程序编写顺序打乱——即写在后面的代码在时间顺序上可能会先执行，而写在前面的代码会后执行——以尽可能充分地利用CPU就会出现指令重排序(happen-before)，从而导致上面的三个步骤执行顺序发生改变。正常情况下是123，但是如果指令重排后执行为1,3,2那么久会导致instance 为空，进而导致程序出现问题。既然已经知道了上述双重检测机制会出现问题，那么我们该怎么避免出现，该如何解决呢?在java语言中有一个关键字volatile，我们都知道它提供了内存可见性这一特性，其实它还有一个作用就是防止指令重排序，那么我们把变量singleton用volatile修饰下就可以了。饿汉式饿汉式与懒汉式区别是它在类加载的时候就进行初始化操作，而懒汉式是调用getInstance()方法时才进行初始化，有延迟加载的作用。1234567891011121314151617181920212223242526272829303132/** \\* Created by Code4Android *4饿汉式 */public class HungrySingleton &#123; private static HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123;​ System.out.println(\"初始化\"); &#125; public static HungrySingleton getInstance()&#123;​ return instance; &#125; &#125;与懒汉式相比，它是线程安全的（无需用同步关键字修饰），由于没有加锁，执行效率也相对较高，但是也有一些缺点，在类加载时就初始化，会浪费内存。静态块实现方式123456789101112131415161718192021222324252627282930313233343536/** \\* *5静态块 */public class HungrySingleton&#123; private HungrySingleton instance = null; //饿汉式变种5 static &#123;​ instance = new HungrySingleton(); &#125; private HungrySingleton() &#123;​ System.out.println(\"初始化\"); &#125; public static HungrySingleton getInstance()&#123;​ return instance; &#125;&#125;静态内部类实现方式1234567891011121314151617181920212223242526272829303132333435/** \\* *6静态内部类 */public class StaticInnerClassSingleton &#123; private static class SingletonHolder &#123;​ private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); &#125; private StaticInnerClassSingleton() &#123;​ System.out.println(\"初始化\"); &#125; public static final StaticInnerClassSingleton getInstance() &#123;​ return SingletonHolder.INSTANCE; &#125;&#125;静态内部类相对实现较为简单，并且它是一种懒加载机制， 当Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。枚举123456789101112131415161718192021222324252627282930/** \\* \\* 7默认枚举实例的创建是线程安全的 */public enum EnumSinglton &#123; INSTANCE; private EnumSinglton() &#123;​ System.out.println(\"构造方法\"); &#125; public void doSomething() &#123;​ System.out.println(\"调用单例方法\"); &#125; &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.ljchengx.cn/categories/JAVA/"},{"name":"Android","slug":"JAVA/Android","permalink":"http://www.ljchengx.cn/categories/JAVA/Android/"}],"tags":[{"name":"单例","slug":"单例","permalink":"http://www.ljchengx.cn/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"项目干系人管理","slug":"项目干系人管理","date":"2020-01-21T06:02:29.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目干系人管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E5%B9%B2%E7%B3%BB%E4%BA%BA%E7%AE%A1%E7%90%86/","excerpt":"","text":"1.影响项目的人2.受项目影响的人识别干系人：输入工具与技术输出1.项目章程 2.采购文件 3.事业 4.组织1.干系人分析 2.专家判断 3.会议1.干系人登记册干系人登记册：1.基本信息 姓名 职位 联系方式等2.评估信息 主要需求 主要期望 潜在影响3.干系人分类 关键干系人/非关键干系人规划干系人管理：输入工具与技术输出1.项目管理文件 2.干系人登记册 3.事业 4.组织1.专家判断 2.会议 3.分析技术1.干系人管理计划 2.项目文件更新分析技术：管理干系人参与：输入工具与技术输出1.关系人管理计划 2.沟通管理计划 3.组织 4.事业1.沟通方法 2.人际关系技能 3.管理技能1.问题日志 2.变更请求 3.项目管理计划更新 4.项目文件更新 5.组织过程资产更新管理干系人参与活动：帮助项目经理提升来自干系人的支持 并把干系人的抵制降到最低 从未显著提升项目成功的机会控制干系人管理：输入工具与技术输出1.项目管理计划 2.问题日志 3.工作绩效数据 4.项目文件1.信息管理系统 2.专家判断 3.会议1.工作绩效信息 2.变更请求 3.项目管理计划更新 4.项目文件更新 5.组织过程资产更新","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"干系人","slug":"干系人","permalink":"http://www.ljchengx.cn/tags/%E5%B9%B2%E7%B3%BB%E4%BA%BA/"}]},{"title":"项目合同管理","slug":"项目合同管理","date":"2020-01-21T06:00:07.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目合同管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E5%90%88%E5%90%8C%E7%AE%A1%E7%90%86/","excerpt":"","text":"合同的类型(范围)：总承包合同 ：全过程作为一个整体发包给同一个卖方()单项工程承包合同：只承包项目中的某一项或几项内容分包合同：总承包人将某一部分分包出去 (买方认可 非主体工作 分包部分不是整体 具有相应资质 分包之后不可再分包)合同的类型(付款方式)：1.总价合同2.成本补偿合同3.工料合同合同的内容：合同签订管理：合同履行管理：","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"合同","slug":"合同","permalink":"http://www.ljchengx.cn/tags/%E5%90%88%E5%90%8C/"}]},{"title":"项目人力资源管理(二)","slug":"项目人力资源管理-二","date":"2020-01-21T02:32:04.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目人力资源管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"组建项目团队输入工具与技术输出1.人力资源管理计划 2.事业环境因素 3.组织过程资产1.预分派 2.谈判 3.招募 4.虚拟团队 5.多标准决策分析1.项目人员分派 2.资源日历 3.项目管理计划更新建设项目团队输入工具与技术输出1.人力资源管理计划 2.项目人员分派 3.资源日历1.人际关系技能 2.培训 3.团队建设活动 4.基本规则 5.集中办公 6.认可和奖励 7.人事评测工具1.团队绩效评价 2.事业环境因素更新人事评定工具管理项目团队输入工具与技术输出1.人力资源管理计划 2.项目人员分配 3.团队绩效评价 4.问题日志 5.工作绩效评价 6.组织过程资产1.观察与交谈 2.项目绩效评价 3.冲突管理 4.人际关系能力1.变更请求 2.项目管理计划 3.项目文件更新 4.事业环境因素更新 5.组织过程资产冲突管理冲突的解决","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"人力资源","slug":"人力资源","permalink":"http://www.ljchengx.cn/tags/%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90/"}]},{"title":"项目人力资源管理(一)","slug":"项目人力资源管理-一","date":"2020-01-21T02:28:28.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目人力资源管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"1.领导和管理领导者：确定方向 统一思想 激励和鼓舞管理者：被组织赋予职位和权力 负责某件事情的管理或实现某个目标领导者设定目标 管理者率众实现目标项目经理有领导者和管理者的双重身份2.权力：职位权力 管理者在组织中的职位和职权惩罚权力 使用降职 扣薪等奖励权力 升职 加薪专家权力 来源个人的专业技能 某些领域的专业权威参照权力 源于他人对你的认可和敬佩 愿意服从和模仿马斯洛需求层次理论赫兹伯格的双因素理论麦格雷戈的X Y理论期望理论：激发力量 = 目标效价*期望值人力资源管理内容规划人力资源管理输入工具与技术输出1.项目管理计划 2.活动资源需求 3.事业 4.组织1.组织图和职位描述 2.人际交往 3.组织理论 4.专家判断 5.会议1.人力资源管理计划人际交往：积极沟通 午餐会 非正式交谈和行业会议组织理论：阐述人员 团队和组织管理人力资源管理计划","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"人力资源","slug":"人力资源","permalink":"http://www.ljchengx.cn/tags/%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90/"}]},{"title":"项目采购管理","slug":"项目采购管理","date":"2020-01-21T02:25:56.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目采购管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E9%87%87%E8%B4%AD%E7%AE%A1%E7%90%86/","excerpt":"","text":"1.规划采购2.实施采购3.控制采购4.结束采购规划采购管理：输入工具与技术输出1.项目管理计划 2.需求文档 3.风险登记册 4.活动资源需求 5.项目进度 6.活动成本估算 7.干系人登记册 8.事业 9.组织1.自制采购外购分析 2.专家 3.市场调研 4.会议1.采购管理计划 2.采购工作说明书 3.采购文件 4.供方选择标准 5.自制外购决策 6.变更申请 7.项目文件更新实施采购：输入工具与技术输出1.采购管理计划 2.采购文件 3.供方选择标准 4.卖方建议书 5.项目文件 6.自制外购决策 7.采购工作说明书 8.组织过程资产1.投标人会议 2.建议书评价技术 3.独立估算 4.专家判断 5.刊登广告 6.分析技术 7.采购谈判1.选择的卖方 2.协议 3.资源日历 4.变更请求 5.项目管理计划更新 6.项目文件更新控制采购：输入工具与技术输出1.项目管理计划 2.采购文件 3.合同 4.批准的变更请求 5.工作绩效报告 6.工作绩效数据1.合同变更控制系统 2.采购绩效审查 3.检查与审计 4.报告绩效 5.支付系统 6.索赔管理 7.记录管理系统1.工作绩效信息 2.变更请求 3.项目管理计划更新 4.项目文件更新 5.组织更新结束采购：","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"采购","slug":"采购","permalink":"http://www.ljchengx.cn/tags/%E9%87%87%E8%B4%AD/"}]},{"title":"项目沟通管理","slug":"项目沟通管理","date":"2020-01-21T02:23:55.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目沟通管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E6%B2%9F%E9%80%9A%E7%AE%A1%E7%90%86/","excerpt":"","text":"规划沟通管理输入工具与技术输出1.项目管理计划 2.干系人登记册 3.事业 4.组织1.沟通需求分析 2.沟通技术 3.沟通模型 4.沟通方法 5.会议1.沟通管理计划 2.项目文件更新沟通需求分析：对组织结构图 责任关系 涉及学科专业 项目人数地点 内外部信息需要以及对干系人的信息和沟通需求进行分析以确定干系人的信息需求，包括信息的类型和格式 以及信息对干系人的价值沟通渠道：N(N-1)/2沟通技术：简答交流到冗长的会议影响包括：信息需求的紧迫性 可用性 易用性等沟通模型：沟通方法：交互式推式拉式管理沟通：输入工具与技术输出1.沟通管理计划 2.工作绩效报告 3.事业 4.组织1.沟通技术 2.沟通模型 3.沟通方法 4.信息管理系统 5.报告绩效1.项目沟通 2.项目管理计划 3.项目文件更新 4.组织过程资产更新报告绩效：收集和发布信息 分析现状 进展以及预测结果的汇报绩效的工作控制沟通：输入工具与技术输出1.沟通管理计划 2.项目沟通 3.问题日志 4.工作绩效数据 5.组织过程资产1.信息管理系统 2.专家判断 3.会议1.工作绩效信息 2.变更请求 3.项目管理计划更新 4.项目文件更新 5.组织过程资产更新补充：","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"沟通","slug":"沟通","permalink":"http://www.ljchengx.cn/tags/%E6%B2%9F%E9%80%9A/"}]},{"title":"项目风险管理(二)","slug":"项目风险管理-二","date":"2020-01-21T02:20:26.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目风险管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"定量风险分析：输入工具与技术输出1.风险管理计划 2.成本管理计划 3.进度管理计划 4.风险登记册 5.事业 6.组织1.数据收集和展示技术 2.定量风险分析和建模技术 3.专家判断1.项目文件更新 2.风险登记册更新包括： 项目的概率分布 实现成本和时间目标的概率 量化的风险优先级清单 定量风险分析的结果规划风险应对：1.风险管理计划 2.风险登记册1.消极风险或威胁的应对策略 2.积极风险或机会的应对策略 3.应急应对策略 4.专家判断1.项目管理计划 2.项目文件更新1.消极风险或者威胁的应对策略避免：采取行动，消除风险 如改变计划 改变策略 放宽项目目标转移：转移给第三方 如保险 分包减轻：采取行动 降低风险概率或降低影响接受：被动 主动2.积极风险或机会的应对策略开拓：积极进取 确保机会实现 采取全新技术 分配更多有能力的资源提高：提高机会发生的概率 如增加资源培训分享：同第三方一起分享积极风险 互惠互利接受 机会发生时乐于利用 但不主动追求机会3.应急应对策略项目文件更新内容:风险的责任人及分派给他们的职责商定的应对措施实施选定的应对策略所需的具体行动风险发生的触发条件征兆和警示实施选定的应对策略所需的预算和进度活动应急计划以及应急计划实施的触动因素对策实施之后预计仍将残留的风险实施风险应对措施直接造成的二次风险控制风险：输入工具与技术输出1.项目管理计划 2.风险登记册 3.工作绩效数据 4.工作绩效报告1.风险再评估 2.风险审计 3.偏差和趋势分析 4.技术绩效测量 5.储备分析 6.会议1.工作绩效信息 2.变更请求 3.项目管理计划更新 4.项目文件更新 5.组织过程资产更新1.风险再评估 识别新风险 现风险的再评估 删除过时风险2.风险审计 定期的风险评审3.偏差和趋势分析 分析偏差 预估趋势 揭示进度4.技术绩效测量 将取得技术成果与计划相比5.储备分析 分析确定剩余应急储备与剩余的风险相匹配做题记录:德尔菲技术技术和鱼骨图是对风险识别过程使用。按照风险可能造成的后果，可以将风险划分为纯粹风险和投机风险。权变措施是风险监控过程中，对未识别的风险进行临时权变处理。","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"风险","slug":"风险","permalink":"http://www.ljchengx.cn/tags/%E9%A3%8E%E9%99%A9/"}]},{"title":"项目风险管理(一)","slug":"项目风险管理-一","date":"2020-01-21T02:17:22.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目风险管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"风险的属性1.风险事件的随机性 偶然性2.风向的相对性 相对项目活动主体而言 承受力不同 影响不同 收益大小 投入太小 主体的地位和资源3.风险的可变性 条件变化 会引起风险的变化风险态度的影响因素：风险偏好风险承受力风险临界值风险分类：按性质按产生原因按是否可管理按影响范围按后果承担者按可预测性规划风险管理：输入工具与技术输出1.项目管理计划 2.项目章程 3.干系人登记册 4.事业 5.组织1.分析技术 2.专家判断 3.会议1.风险管理计划风险管理计划：方法论角色和职责预算时间安排风险类别：风险分解结构风险概率和影响力的定义风险概率和影响矩阵修改的干系人承受度报告格式跟踪：如何记录和风险审计识别风险：输入工具与技术输出1.风险管理计划 2.成本管理计划 3.进度管理计划 4.质量管理计划 5.人力资源管理计划 6.范围基准 7.活动的成本估算 8.活动持续时间估算 9.干系人登记册 10.项目文件 11.采购文件 12.事业 13.组织1.文档审查 2.信息收集技术 3.核对单分析 4.假设分析 5.图解技术 6.SWOT分析 7.专家判断1.风险登记册实施定性风险分析：输入工具与技术输出1.风险管理计划 2.范围基准 3.风险登记册 4.事业 5.组织1.风险概率和影响评估 2.概率和影响矩阵 3.风险数据质量评估 4.风险分类 5.风险紧迫性评估 6.专家判断1.项目文件更新","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"风险","slug":"风险","permalink":"http://www.ljchengx.cn/tags/%E9%A3%8E%E9%99%A9/"}]},{"title":"项目进度管理(二)","slug":"项目进度管理-二","date":"2020-01-21T01:54:08.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目进度管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"制定进度计划输入工具与技术输出1.进度管理计划 2.活动清单 3.活动属性 4.项目进度网络图 5.活动资源需求 6.资源日历 7.活动历时估算 8.项目范围说明书 9.风险登记册 10.项目人员分配 11.需求分解结构 12.事业 13.组织1.进度网络分析 2.关键路径法 3.关键链法 4.资源优化技术 5.提前量和滞后量 6.进度压缩 7.进度计划编制工具 8.建模技术1.进度基准 2.项目进度计划 3.进度数据 4.项目日历 5.项目管理计划更新 6.项目文件更新关键路径法时间最长的路径总浮动时间(总时间)：不延误项目完成日期 路径上活动可推迟的时间 注：关键路径上没有总时差自由浮动时间(自由时差)：非关键路径上不影响任何紧后活动最早开始日期下 本活动可推迟的时间注：唯一紧前活动没有自由时差 关键路径上的活动没有自由时差关键链法帕金森定律学生综合症解决：最早开始法则 越早越好 砍掉每个活动的浮动时间资源平衡：可以提高资源使用率 但可能导致关键路径延长资源平滑：利用活动的浮动时间 不会改变项目关键路径建模技术：蒙特卡洛进度压缩：加班快速跟进进度基准：经批准的进度模型 1.项目进度计划 2.进度数据控制进度输入工具与技术输出1.项目管理计划 2.项目进度计划 3.工作绩效数据 4.项目日历 5.进度数据 6.组织过程资产1.绩效审查 2.项目管理软件 3.资源优化技术 4.建模技术 5.提前量和滞后量 6.进度压缩 7.进度计划编制工具1.工作绩效信息 2.进度预测 3.变更请求 4.项目管理计划 5.项目文件更新 6.组织过程资产更新缩短工期的办法：1.赶工 投入更多的资源或增加工作时间 缩短关键路径上活动的工期2.快速跟进 并行施工3.使用高素质的资源或经验丰富的人才4.减小活动范围或降低要求5.改进方法和技术，提高生产效率6.加强质量管理 及时发现问题","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"进度","slug":"进度","permalink":"http://www.ljchengx.cn/tags/%E8%BF%9B%E5%BA%A6/"}]},{"title":"项目进度管理(一)","slug":"项目进度管理-一","date":"2020-01-21T01:53:14.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目进度管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"项目进度管理规划进度管理输入工具与技术输出1.项目管理计划 2.项目章程 3.事业 4.组织1.专家判断 2.分析技术 3.会议1.进度管理计划定义活动输入工具与技术输出1.进度管理计划 2.范围基准 3.事业 4.组织1.分解 2滚动式规划 3.专家判断1.活动清单 2.活动属性 3.里程碑清单活动清单:列出项目开展的全部活动 确保项目团队成员明确自己的工作和责任，知道如何完成工作。活动清单属性：包括活动表示 WBS标识 活动标签或名称里程碑清单：主要可交付物 持续时间为0 不消耗成本例如：可研完成 可交付物为可行性研究报告排列活动顺序输入工具与技术输出1.进度管理计划 2.活动清单 3.活动属性 4.里程碑清单 5.项目范围说明 6.事业 7.组织1.紧前关系 2.确定依赖关系 3.提前量和滞后量1.项目进度网络 2.项目文件更新PDM四种逻辑关系：FS 完成到开始FF 完成到完成 (产品开发完成 控制质量也就完成了)SS 开始到开始 (地基浇灌 路面平整)SF 开始到完成 (新旧系统切换)箭线图法：双代号网络图 每一件事必须有一个唯一代号 不重复任两项活动的紧前事件和紧后事件代号 至少有一个不同确认依赖关系：1.强制性依赖 硬逻辑关系2.选择性依赖 首选逻辑关系 优先逻辑关系提前量和滞后量：A–提前-10分钟-&gt;BA–滞后+28天-&gt;B估算活动资源输入工具与技术输出1.进度管理计划 2.活动清单 3.活动属性 4.资源日历 5.风险登记册 6.活动成本估算 7.事业 8.组织1.专家判断 2.备选方案分析 3.发布的估算数据 4.自下而上的估算 5.项目管理软件1.活动资源需求 2.资源分解结构 3.项目文件更新估算活动持续时间输入工具与技术输出1.进度管理计划 2.活动清单 3.活动属性 4.活动资源需求 5.资源日历 6.项目范围说明书 7.风险登记册 8.资源分解结构 9.事业环境因素 10.组织1.专家判断 2.类比估算 3.参数估算 4.三点估算 5.群体决策技术 6.储备分析1.活动历时估算 2.项目文件更新三点估算1.个标准差 68.26%2.个标准差 95.43%3.个标准差 99.73%","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"进度","slug":"进度","permalink":"http://www.ljchengx.cn/tags/%E8%BF%9B%E5%BA%A6/"}]},{"title":"项目成本管理(二)","slug":"项目成本管理-二","date":"2020-01-21T01:49:44.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目成本管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"成本控制的内容：控制成本输入工具与技术输出1.项目管理计划 2.项目资金需求 3.工作绩效数据 4.组织1.挣值管理 2.预测 3.完工尚需绩效指数 4.绩效审查 5.项目管理软件 6.储备分析1.工作绩效信息 2.成本预测 3.变更请求 4.项目管理计划 5.项目文件更新 6.组织过程资产更新挣值管理综合了范围 时间 成本绩效测量的方法术语解释举例计划价值BAC项目完工预算(不含管理储备)规划10天种100棵树 1010010 =10000实际成本AC已完成工作的实际成本实际种30棵 但是花费4500计划价值PV应完成工作的计划价值第五天结束，应为50棵 50*1000=5000块挣值EV实际已完成工作的计划价值已种30棵 单价100 30*100=3000进度偏差SVEV-PV 小于0 进度落后 大于0进度超前–进度绩效指数SPIEV/PV 小于1 落后 大于1提前–成本偏差EV-AC 小于0 超支 大于0节约–成本绩效指数CPIEV/AC 小于1 超支 大于1节约–ETC（非典型）完工尚需估算(非典型的特殊情况，以后不会发生) ETC = BAC-EV10000-3000EAC完工估算 EAC = AC +ETC4500+ETCETC(典型)ETC= (BAC-EV)/CPI CPI = EV/AC(10000-3000)/0.6667 7000*4500/3000EACEAC = AC+ETC 快速公式 EAC = BAC/CPI–TCPI（按原预算）（BAC-EV）/ (BAC-AC) &gt;1 难完成 =1 完成 &lt;1 容易完成（10000-3000）/ (10000-4500) 大于1 难完成 绩效水平需要到达1.27倍TCPI(按新估算)（BAC-EV）/ (EAC-AC) &gt;1 难完成 =1 完成 &lt;1 容易完成情况1 非典型 （10000-3000）/(11500-4500) 情况2 典型 （10000-3000）/ (14999-4500)记忆口诀：不管是成本还是进度 小于就不是好事 进度落后 成本超支","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"成本","slug":"成本","permalink":"http://www.ljchengx.cn/tags/%E6%88%90%E6%9C%AC/"}]},{"title":"项目成本管理(一)","slug":"项目成本管理-一","date":"2020-01-21T01:48:09.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目成本管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9C%AC%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"成本失控的原因：1.对项目认识不足2.组织制度不完善3.方法问题4.技术的制约5.需求管理不当成本类型：可变成本 材料固定成本 折旧直接成本 工资 团队差旅费 物料 设备间接成本 分摊 税金 额外福利 保卫费用机会成本沉没成本 历史成本 对现有决策而言是不可控成本学习曲线：重复生成产品时 产品的单位成本会随着产量扩大呈规律性递减规划成本管理输入工具与技术输出1.项目管理计划 2.项目章程 3.事业 3.组织1.专家判断 2.分析技术 3.会议1.成本管理计划估算成本：输入工具与技术输出1.成本管理计划 2.人力资源管理计划 3.范围基准 4.项目进度计划 5.风险登记册 6.事业 7.组织1.专家判断 2.类比估算 3.参数估算 4.自下而上估算 5.三点估算 6.储备分析 7.质量成本 8.项目管理估算软件 9.卖方投标分析 10群体决策技术1.活动成本估算 2.估算依据 3.项目文件更新[]类比:简单易行 自上而下 耗时小 成本低参数：取决历史数据卖方投标协议：根据卖方的投标情况 分析成本制定预算输入工具与技术输出1.成本管理计划 2.范围基准 3.活动成本估算 4.估算依据 5.项目进度计划 6.资源日历 7.风险登记册 8.协议 9.组织1.成本汇总 2.储备分析 3.专家判断 4.历史关系 5.资金限制平衡1.成本基准 2.项目资金需求 3.项目文件更新","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"成本","slug":"成本","permalink":"http://www.ljchengx.cn/tags/%E6%88%90%E6%9C%AC/"}]},{"title":"项目质量管理(二)","slug":"项目质量管理-二","date":"2020-01-21T01:43:51.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目质量管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"控制质量输入工具与技术输出1.项目管理计划 2.质量测量指标 3.质量核对单 4.工作绩效数据 5.批准的变更请求 6.可交付成果 7.项目文件 8.组织1.老七工具 2.统计抽样 3.检查 4.审查已批准的变更请求1.质量控制测量结果 2.确认的变更 3.核实的可交付成果 4.工作绩效信息 5.变更请求 6.项目管理计划更新 7.项目文件更新 8.组织过程资产的更新老七工具：因果图(鱼骨图) ：分析原因 识别问题 找根本原因流程图：SIPOC模型 有助于了解和估算一个过程的质量成本核查表：产品出现质量问题的原因统计帕累托图：又称排列图 二八原理 20%的原因 造成80%的问题 找出和解决主要原因直方图：排列明细控制图：散点图：新七工具1.亲和图 针对某个问题 形成有组织的想法 形成各种创意或者问题解决方法2.过程决策程序 用于理解目标与达成它的步骤之间关系3.关联图 有助于在包含相互交叉逻辑关系中等复杂情形中创新地解决问题4.树形图 层次分解形式 直观展示5.优先矩阵图 识别关键事项和合适的备选方案 通过一系列决策 排列优先顺序6.活动网络图 AOA (双) AON(单)7.矩阵图 在行列交叉的位置展示因素 原因和目标之间的关系强弱做题记录:1.质量计划编制阶段的输出包括为质量管理计划，质量度量指标，质量检查单，过程改进计划，更新的项目管理计划。2.基准分析是质量计划编制过程常用的工具和技术。3.质量计划是为具体产品，项目，服务和合同准备的。4.在质量管理的循环中。P阶段包括明确质量要求和目标，提出质量管理方案。5.在质量规划中，实验设计是一种统计分析技术，可用来帮助人们识别并找出哪些变量对项目的结果影响最大。6.找根本原因，就用因果图。7.在六西格玛管理法中。西格玛的值越大，过程故障率越低。8.系统开发过程中，设计评审属于质量控制工作。9.质量保证说明书，在所有的项目中要提供项目内部和项目外部的质量保证，其目的是说明项目满足相关质量标准的保证能力。10.识别相关质量标准是编制质量规划的首要的工作。11.确定是用于项目的质量标准，并决定如何满足这些标准是质量计划的过程。12.因果分析可以作为项目质量控制中问题识别和问题分析的工具。13.质量控制方法中,控制图可以用来分析过程是否稳定，是否发生了异常情况。鱼骨图直观地反映了项目中可能出现的问题与各种潜在原因之间的关系。14.新七工具中过程决策程序图适用于理解一个目标与达成此目标步骤之间的关系。15.质量保证，旨在建立对未来输出或正在进行的工作完成，是满足特定的需求和期望的信心。","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"质量","slug":"质量","permalink":"http://www.ljchengx.cn/tags/%E8%B4%A8%E9%87%8F/"}]},{"title":"项目质量管理(一)","slug":"项目质量管理-一","date":"2020-01-21T01:40:42.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目质量管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"PDCA 戴明环P:计划明确目标 确定方案分析现状找出原因确定主因制定方案措施D:实施 执行C:检查A：行动 修正 总结 标准化质量管理标准体系：ISO9000八项基本原则：1.以顾客为中心2.领导作用3.全员参与4.过程方法5.管理的系统方法6.持续改进7.基于事实的决策方法8.与供方互利的关系全面质量管理4个组成要素：结构 技术 人员 变革推动者4个核心特征：全员 全过程 全面方法 全面结构六西格玛：规划质量管理输入工具与技术输出1.项目管理计划 2.干系人登记册 3.风险登记册 4.需求文件 5.事业 6.组织1.成本收益分析 2.质量成本 3.七种基本质量工具 4.标杆对照 5.实验设计 6.统计抽样 7.其他1.质量管理计划 2.过程改进计划 3.质量测量指标 4.质量核对单 5.项目文件更新1.成本收益分析2.质量成本实施质量保证输入工具与技术输出1.质量管理计划 2.过程改进计划 3.质量测量指标 4.质量控制测量结果 5.项目文件1.质量管理和控制工具 2.质量审计 3.过程分析1.变更请求 2.项目管理计划更新 3.项目文件更新 4.组织过程资产更新质量保证：QA通过规划过程预防缺陷或者在执行阶段对正在进行的工作检查出缺陷来保证一致性工作(预防、评估)","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"质量","slug":"质量","permalink":"http://www.ljchengx.cn/tags/%E8%B4%A8%E9%87%8F/"}]},{"title":"项目范围管理(二)","slug":"项目范围管理-二","date":"2020-01-21T01:33:23.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目范围管理-二/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86-%E4%BA%8C/","excerpt":"","text":"创建WBS输入工具与技术输出1.范围管理计划 2.项目范围说明书 3.需求文件 4.组织过程资产1.分解 2.专家判断1.范围基准 2.项目文件更新创建工作分解结构说明明确和准确说明项目范围清楚的定义项目的边界为各独立单元分派人员 规定这些人员的职责针对独立单元 估算为计划预算进度安排和费用控制奠定基础项目工作和财务账目联系起来确定工作的内容和顺序有助于防止需求蔓延分解总述工作包 项目工作分解更小的单元 易于管理滚动式计划 分解到详细工作包以便安排分解级别 工作包最小不小于8小时 最大不超过80小时全员参与 项目干系人和项目团队成员共同参与活动及步骤分解是否正确要素足够详细–&gt;充分且必要–&gt;清晰完整–&gt;能恰当编制预算和进度–&gt;能够分配到具体组织单元分解注意事项WBS必须面向可交付成果必须符合项目的范围底层支持计划和控制元素必须有人负责 且只有一个人负责控制在4~6层 一个工作单元只能从属某个上层单元 避免交叉包括项目管理工作也包括分包出去的工作需要项目干系人参与 需要团队成员并非一成不变 可以修改输出 –范围基准已批准的项目范围说明书 项目范围 主要可交付成果 边界 假设和制约WBS 控制账户：管理控制点WBS词典 工作包的细节描述确认范围输入工具和技术输出项目管理计划 2.需求文件 3.需求跟踪矩阵 4.核实的可交付成果 5.工作绩效数据1.检测 2,。群体决策技术1.验收的可交付成果 2.变更请求 3.工作绩效数据 4.项目文件的更新工具：检查 也叫审查 产品评审 走查 审计 巡检 包括测量测试检验等控制范围输入工具与技术输出1.项目管理计划 2.需求文件 3.需求跟踪矩阵 4.工作绩效数据 5.组织过程资产1.偏差分析1.工作绩效数据 2.变更请求 3.项目管理计划 4.项目文件更新 5.组织过程资产更新范围蔓延：范围潜变 未经控制的产品或项目范围的扩大镀金 擅自新增工作或者产品功能(未受控)1.如果产品范围做了变更，下一步应该调整项目范围。2.详细的范围说明书描述了项目的可交付物和产生这些可交付物所必须做的项目工作。3.项目范围变更控制，包括审批项目范围变更的一系列过程，包括书面文件，跟踪系统和授权变更所必须的批准级别。4 .是否明确了变更申请不能作为检验WBS是否定义完全。5.对项目的绩效情况进行分析，确定是否偏离设定的范围基准，属于项目范围控制活动。6.收集需求，定义范围，创建工作分解结构，核实范围，控制范围属于范围，管理流程的正确顺序。7.在创建工作分解结构时，描述生产一个产品所需要的实际部件，组件的分解层次表格称为物料清单。8.偏差分析是控制范围，常用的工具技术。","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"范围","slug":"范围","permalink":"http://www.ljchengx.cn/tags/%E8%8C%83%E5%9B%B4/"}]},{"title":"项目范围管理(一)","slug":"项目范围管理-一","date":"2020-01-21T01:27:20.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/项目范围管理-一/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86-%E4%B8%80/","excerpt":"","text":"范围管理范围管理概述确保项目包含且只包含达到项目成功所必须完成的工作明确项目的边界对项目执行工作进行监控防止项目范围发生蔓延范围管理的重要性：完成项目工作范围是为了实现项目目标项目范围管理和控制的有效性，是衡量项目是否达到成功的一个必要标准不断重申项目工作范围，是项目实施控制管理的一个主要手段界定分工和责任明确主要可交付成果影响项目成果故事分享：花时间收集关键干系人需求，重新梳理，重新规划项目范围，分步完成规划范围管理输入工具与技术输出1.项目管理计划 2.项目章程 3.事业 4.组织专家判断 5.会议1.范围管理计划 2.需求管理计划范围管理计划：对团队如何管理项目范围提供指导需求管理计划：如何分析 记录和管理需求 是对项目的需求进行定义 确认等收集需求输入工具与技术输出范围管理计划 2.需求管理计划 3.干系人管理计划 4.项目章程 5干系人登记册1.访谈 2.焦点小组 3.引导式研讨会 4.群体创新技术 5.群体决策技术 6.问卷 7.观察 8.原型法 9.标杆对照 10.系统交互图 11.文件分析1.需求文件 2.需求跟踪矩阵工具与技术访谈：1.准备 –了解对象 准备提纲 让被访者上司安排2.访谈时 –2人去 聆听非指导 复述和确认 引导描述事实 把握需求实质3.结束 –感谢 反馈焦点小组会议：预定的干系人和主题专家集中讨论引导式研讨会：跨职能 集中式讨论JAD 联合应用设计/开发 关系人+开发团队QFD 质量工程展开 客户声音群体创新技术：头脑风暴：面对面 互相启发 追求数量名义小组：通过投票来排列最有用的创意 以便进一步的头脑风暴德尔菲技术：匿名 以问卷方式多次征询专家意见思维导图：放射性亲和图：多标准决策:借助决策矩阵 采用多标准评估和排序方式需求文件业务需求 干系人需求 解决方案需求 项目需求 过度需求 相关假设和约束需求跟踪矩阵将产品需求从其来源连接到能足需求的可交付成果的一种表格定义范围输入工具与技术输出1.范围管理计划 2.项目章程 3.需求文件 4.组织1.专家判断 2.；产品分析 3.备选方案 4.引导式研讨会1.项目范围说明书 2.项目文件更新产品分析：产品分解系统工程/系统分析价值工程/价值分析功能(需求)分析备选方案生成1.备选方案分析2.横向思维范围说明书：产品范围描述 助记 ： 产 验 可 除 制 假验收标准可交付成果项目的除外责任制约因素假设条件范围说明书主要作用：确认范围 2. 沟通基础 3. 规划和控制依据变更基础 5. 规划基础","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"范围","slug":"范围","permalink":"http://www.ljchengx.cn/tags/%E8%8C%83%E5%9B%B4/"}]},{"title":"信息文档管理与配置管理","slug":"信息文档管理与配置管理","date":"2020-01-21T00:58:03.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/21/信息文档管理与配置管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/21/%E4%BF%A1%E6%81%AF%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/","excerpt":"","text":"1.信息文档管理开发文档：描述开发过程1）可行性研究和项目任务书2）需求规格说明3）功能规格说明4）设计规格说明5）开发计划6）软件集成和测试计划7）质量保证计划8）安全和测试信息产品文档：1）培训手册2）参考手册和用户指南3）软件支持手册4）产品手册和信息广告管理文档：1）进度及进度变更记录2）软件变更情况的记录3）开发团队的职责定义4）项目计划5）配置管理计划文档质量分为四级2.配置管理CMO配置管理员严格管理基本配置项向开发人员开放读取权限配置项状态草稿 正式 修改配置项版本号1.处理草稿状态 开头为0 0.YZ 01~992.处理正式发布的为 X.Y 如 1.03.修改状态 X.YZ 1.72配置基线：由一组配置项组成 由CCB审核配置库：1.动态库(开发库)2.受控库(主库)3.静态库(产品库)","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"文档","slug":"文档","permalink":"http://www.ljchengx.cn/tags/%E6%96%87%E6%A1%A3/"},{"name":"配置","slug":"配置","permalink":"http://www.ljchengx.cn/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"指导与管理项目工作","slug":"指导与管理项目工作","date":"2020-01-19T09:01:42.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/19/指导与管理项目工作/","link":"","permalink":"http://www.ljchengx.cn/2020/01/19/%E6%8C%87%E5%AF%BC%E4%B8%8E%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"指导与管理项目工作输入工具与技术输出1.项目管理计划 2.批准的变更请求 3.事业环境因素 4.组织过程资产1.专家判断 2.项目管理 信息系统 3.会议1.可交互成果 2.工作绩效数据 3.变更请求 4.项目管理计划更新 5.项目文件更新相关活动：开展活动 —实现项目目标付出资金 —付出努力与资金 实现项目目标培训人员 —配备 培训并管理分派到项目的团队成员取得报价 —根据情况取得报价 标书 要约或建议书选定卖方 —在潜在的卖方中间进行比较 选定卖方取得资源 —取得 管理并使用资源 包括材料 工具 设备等实施方法 —实施已列入计划的方法和目标及标准创造结果 —创造 控制 核实并确认项目可交付成果管理风险 —管理风险并实施风险应对活动管理卖方纳入变更 —将批准的变更纳入项目的范围 计划和环境建立渠道 —建立并管理项目团队内外的项目沟通渠道收集数据 —收集项目数据 并报告费用 进度技术与质量绩效收集教训 —收集与记载吸取的教训项目管理信息系统进度计划工具工作授权系统配置管理系统信息收集与发布系统监控项目工作输入工具与技术输出1.项目管理计划 2.进度预测 3.成本预测 4.确认的变更5，工作绩效信息 6.事业 7.组织1.专家判断 2.分析技术 3.项目管理信息系统 4.会议1.变更请求 2.工作绩效报告 3.项目管理计划更新 4.项目文件更新工作绩效数据、信息、报告对比监控项目工作过程的对象对照项目管理计划比较项目的实际表现评价项目的绩效分析 跟踪并监视项目的风险建立有关项目产品以及有关文件的准确和及时的信息库为状态报告 绩效测量和预测提供信息支持更新当前的成本和进度信息预测实施整体变更控制输入工具与技术输出1.项目管理计划 2.工作绩效报告 3.变更请求 4事业 5.组织1.专家判断 2.会议 3.变更控制工具1.批准的变更请求 2.变更日志 3.项目管理计划更新 4.项目文件更新整体变更控制说明整体变更贯穿项目始终项目经理负最终责任只有批准的变更才能纳入修改后的基准项目任何干系人都可以提出变更请求可以口头提出 必须以书面形式记录每一项批准或者否决都需要唯一责任人必要时成立CCB来决策CCB批准之后还需要项目发起人的批准变更控制一般过程变更申请—&gt;评估影响—&gt;变更审批—&gt;更新计划及文件 通知干系人 —&gt;执行变更—&gt;记录变更结束项目或阶段输入工具与技术输出项目管理计划 2.验收的可交付成果 3.组织过程资产1.专家判断 2.分析技术 3.分析1.最终产品服务或成果移交 2.组织过程资产更新","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"管理","slug":"管理","permalink":"http://www.ljchengx.cn/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"项目整体管理","slug":"项目整体管理","date":"2020-01-19T08:56:06.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/19/项目整体管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/19/%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E7%AE%A1%E7%90%86/","excerpt":"","text":"项目整体管理整体概述知识领域包括：识别 确认 结合 统一和协调最重要职责 ：整合通过沟通来协调 通过协调来整合三从四得一关联三从：从过程知输出 2. 从输出想输入 3. 从输入选工具四得：得文件计划 2. 得成果数据 3. 得变更请求 4. 得过程资产一关联：关联过程 前序的输出往往是后续过程的输入制定项目章程批准项目 授权项目经理输入工具与技术输出1.项目工作说明书 2.商业论证 3.协议 4.事业环境因素 5.组织过程资产1.专家判断 2.引导技术项目章程作用：确定项目经理 规定其权利正式确认项目的存在，给项目一个合法的地位规定项目的总体目标把项目与日常组织关联事业环境因素 ：组织或公司的文化和组织结构政府或者行业的标准基础设施现有人力资源人事管理公司工作考核制度市场情况项目干系人风险承受力商业数据库项目管理信息系统主要是内外部的条件、设施、 环境、 系统组织过程资产：组织标准过程 如标准、方针 软件生命周期与项目生命周期标准指导原则、工作指令、建议评价标准模板组织沟通要求项目收尾指导原则或要求财务控制程序变更控制程序风险控制程勋过程测量数据库项目档案历史信息与教训知识库问题和缺陷管理数据库配置管理知识库财务数据库专家判断更具有专业性引导技术头脑风暴冲突处理问题解决会议管理项目章程项目目的或批准项目的原因可测量的项目目标和相关的成功标准项目的总体要求概括性的项目描述项目的主要风险里程碑计划总体预算审批要求委派的项目经理 其职责和职权发起人或者批准人的姓名个职权助记 目的 目标 要审批 风险 进度 预算要审批 项目经理和发起人的职权项目选择方法净现值计算—&gt;越大越好1.1(第一年) 1.21(第二年) 1.331(第三年)。。。 每年的现金流/上面的参数 相加投资收益率计算—&gt;越大越好(总的折现收益 - 总的折现成本)/折现成本投资回收期—&gt;越短越好(累计净值出现正值的年数-1)+出现正值年份的上年累计收益的绝对值/出现正值年份收益值项目启动会议在项目章程确定之后 一般是项目经理召开制定项目管理计划输入工具与技术输出1.项目章程 2其他过程的输出 3.事业环境因素 4.组织过程资产1.专家判断 2.引导技术制定项目管理计划项目管理计划一、计划过程组的各个子计划过程的全部成果项目管理团队选择的各个项目管理过程选定过程的实施水平实施过程需要的工具与技术选定过程的方式和方法 包括过程之间的依赖关系和相互作用实现项目目标所执行工作的方式和方法监控变更的方式 方法实施配置管理的方式 犯法实施效果测量基准并使之保持完整的方式 方法项目干系人之间沟通需要与技术项目生命期和对阶段项目的项目阶段高层管理人员为加快解决未解决的问题和处理未做出的决策二、多个分计划(辅助计划)范围 需求 进度 成本 质量 过程改进 资源 沟通 风险 采购 干系人 管理计划三、其他组成部分里程碑清单 资源日历 进度 成本 质量基准 风险登记册","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"项目组和项目集管理","slug":"项目组和项目集管理","date":"2020-01-19T08:09:28.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/19/项目组和项目集管理/","link":"","permalink":"http://www.ljchengx.cn/2020/01/19/%E9%A1%B9%E7%9B%AE%E7%BB%84%E5%92%8C%E9%A1%B9%E7%9B%AE%E9%9B%86%E7%AE%A1%E7%90%86/","excerpt":"","text":"一、项目组1.项目组合是将项目，项目集以及其他方面的工作内容组合起来进行有效的管理以保证满足组织的战略性的业务目标。二、项目集1.定义：经过协调管理以获取单独管理所无法取得的收益的一组相关联的项目，子项目集合项目集活动项目组合和项目集的最大区别：项目组里的项目没有相关联关系项目集是执行组织战略并实现商业或组织目标和目的的手段项目集管理过程1.项目集管理与项目管理之间的关键区别是项目集的战略聚焦，以及项目集确保组织收益的实现2.项目集路线图按照时间顺序以图形化的方式展示项目集预期发展方向项目集治理-项目指导委员会：主要负责定义并执行恰当的项目集治理体系和方法，保证项目集执行与组织的战略目标保持一致项目集的生命周期1.定义阶段 项目集构建和项目集准备2.收益交付阶段 不断规划 整合和管理 已达成项目集预期收益的交付3.收尾阶段 总结归档","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"项目组","slug":"项目组","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE%E7%BB%84/"},{"name":"项目集","slug":"项目集","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE%E9%9B%86/"}]},{"title":"项目可行性","slug":"项目可行性","date":"2020-01-17T09:18:04.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/17/项目可行性/","link":"","permalink":"http://www.ljchengx.cn/2020/01/17/%E9%A1%B9%E7%9B%AE%E5%8F%AF%E8%A1%8C%E6%80%A7/","excerpt":"","text":"可行性研究内容 项目论证和评估项目立项管理：项目建议书(立项申请) 可行性研究 招投标可行性研究内容：投资必要性 2. 技术可行性 3. 财务可行性组织可行性 5. 经济可行性 6. 社会可行性风险因素及对策可行性研究步骤：机会研究 –&gt; 初步可行性研究 –&gt; 可行性研究评估辅助(功能)研究 ：项目的关键方面初步可行性研究和辅助研究的区别：前者范围较广 后者一两个方面 只涉及关键方面详细可行性研究：科学 客观 公正主要方法：经济评价法 市场预测法 投资估算法 增量效益法详细可行性内容：概述 2. 需求确定 3. 现有资源，设施情况分析设计(初步)技术方案 5. 项目实施进度计划建议 6. 投资估算和资金筹措计划项目组织、人力资源、技术培训计划 8. 经济和社会效益分析 9. 合作/协议方式项目评估和论证主要体现：确定项目是否实施的依据 2. 筹措资金 3. 编制计划设计采购施工及资源配置防范风险，提高项目效率的重要保证","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"可行性","slug":"可行性","permalink":"http://www.ljchengx.cn/tags/%E5%8F%AF%E8%A1%8C%E6%80%A7/"}]},{"title":"软件项目生命周期","slug":"软件项目周期","date":"2020-01-17T08:22:07.000Z","updated":"2021-03-09T07:51:38.448Z","comments":true,"path":"2020/01/17/软件项目周期/","link":"","permalink":"http://www.ljchengx.cn/2020/01/17/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%91%A8%E6%9C%9F/","excerpt":"","text":"软件项目生命周期软件项目生命周期需求阶段–&gt;设计开发阶段–&gt;测试阶段–&gt;交付阶段项目生命期可行性–&gt;规划设计–&gt;实施建造–&gt;启用运转项目收尾时遇见客户的重大变更:另外签合同，做第二期 告知变更代价产品生命期商业计划概念可研–&gt;研发–&gt;生产–&gt;运行和维护–&gt;升级/淘汰项目生命期开始阶段–&gt;中间阶段–&gt;结束阶段单个项目管理过程：启动–&gt;规划–&gt;执行–&gt;监控–&gt;收尾十大知识领域:助记:时间成本范围质量 做项目需要人所以需要人力资源，有人就需要沟通 和干系人沟通 做项目也有风险 需要采购一些设备过程组和十大知识领域关系图启动规划执行监控收尾整体制定项目章程制定项目管理计划指导和管理项目执行1.监控项目工作2.实施整体变更控制结束项目或阶段范围1.规划范围管理 2.收集需求3.定义范围 4.创建WBS1.确认范围 2.控制范围进度1.规划进度 2.定义活动 3.排列活动4.估算资源 5.估算历时 6.制定进度计划控制进度成本1.规划成本管理 2.估算成本3.制定预算控制成本质量规划质量管理实施质量管理实施质量控制人力资源规划人力资源管理1.组建团队 2.建设团队3.管理团队沟通规划沟通管理管理沟通控制沟通风险1.规划风险管理 2.识别风险3.定性分析 4.定量分析 5.规划风险应对控制风险采购规划采购管理实施采购控制采购结束采购干系人识别干系人规划干系人管理管理干系人参与控制干系人参与","categories":[{"name":"信息系统项目管理","slug":"信息系统项目管理","permalink":"http://www.ljchengx.cn/categories/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://www.ljchengx.cn/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"项目","slug":"项目","permalink":"http://www.ljchengx.cn/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"生命周期","slug":"生命周期","permalink":"http://www.ljchengx.cn/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}]}